{
//Basic comments are supported, but they must start with // at the start of the line.
//useful characters: ≤ ≥ ⊂ ⊆ ⊃ ⊇ ⊈ ⊉ = ∩ ⟹ Ω Σ Π Δ
  "problem types":[
    {"name":"Language",
     "desc":"A language is an acceptable set of YES strings. Everything else is a NO string.",
     "isalso":[["Promise Problem","By taking a trivial promise"],
               ["Parameterized Language","By taking a trivial parameter"],
               ["Sampling Problem","By taking a zero-entropy distribution over just the two strings {'YES','NO'}."]]
    },
    {"name":"Promise Problem",
     "desc":"A promise problem has a set of YES strings and a separate set of NO strings. A valid 'solution' to this problem is allowed accept or reject a string that's in neither YES nor NO.",
     "isalso":[["Function Problem","By viewing 'yes' and 'no' as the only acceptable outputs of a function"]]
    },
    {"name":"Function Problem",
     "desc":"A function problem is a relation on pairs of strings; in other words, for each input string, a set of valid output strings.",
     "isalso":[["Optimization problem","By giving a trivial constant objective function f(x,y)=0 and only permitting only valid y for each x"]]
    },
    {"name":"Integer Problem",
     "desc":"An integer problem is a function problem on which each output has exactly one valid output, which is a nonnegative integer. One natural instance is as counting problems, which count strings or paths that satisfy some simpler predicate. This doesn't actually impose a different structure on definition of the problem, but more naturally lets us talk about approximation.",
     "isalso":[["Function Problem","By viewing the outputs as strings instead of integers"],
               ["Approximation Problem","By trying to approximate the counting as accurately as possible"]]
    },
    {"name":"Optimization Problem",
     "desc":"An optimization problem is a problem with a relation R(x,y) of valid solutions, and a real-valued objective function f(x,y). A solver should output a value of y that satisfies the relation and minimizes (or maximizes) f(x,y). Rather than strictly 'correct' or 'incorrect', solutions here are graded based on minimizing (or maximizing) f. Typically R and f are easy to evaluate. You could say that an optimization problem is also a function problem (e.g. give me the single true optimum; alternately, give me any valid point), but this throws way essential structure of the problem in an unrecoverable way, so we don't list it here. There's also an interpretation of optimization problems as parameterized languages, where a problem x becomes a language {(x,k)|k =? opt(x)}, and =? is any relational operator. (Ref: https://www.sciencedirect.com/science/article/pii/S0022000097914902)",
     "isalso":[]
    },
    {"name":"Approximation Problem",
     "desc":"An approximation problem to a real-valued function f(x) asks to find the closest approximation to f(x) given x. It can be graded by additive error |y - f(x)| or multiplicative error |y/f(x) - 1|; the latter requires foreknowledge that f(x) is nonzero.",
     "isalso":[["Optimization Problem","By trying to optimize for the 'best approximation' possible, albeit this has a very difficult to evaluate objective function"],
               ["Parameterized Language","By asking for the value up to an accuracy of epsilon. Epsilon, or perhaps ceil(1/epsilon), would be the parameter; to properly be an accept/reject language (as opposed to a function problem), we take strings (x,y) and a parameter epsilon, and accept iff |y - f(x)| < epsilon."]]
    },
    {"name":"Parameterized Language",
     "desc":"A parameterized language is a set of YES tuples (x,k) and NO tuples (x,k), where x is a string to accept or reject respectively, and k is an integer measuring something about the hardness of the instance. Ultimately this is solved as a language, by classes can have definitions depending on k.",
     "isalso":[["Language","By ignoring the parameter k in the input and studying worst-case behavior using only |x|."]]
    },
    {"name":"Sampling Problem",
     "desc":"A sampling problem is a set of tuples (x,μ), where x is a string describing the instance, and μ is a probability distribution over output strings. The goal is to, given x, output samples from the distribution μ. A common relaxation is to allow the output distribution μ0 to differ slightly from μ, with the restriction that μ0 and μ must have distance at most ϵ (in total variation distance, KL divergence, or some other metric). In that case, the problem may be stated as described as tuples (x,ϵ,μ), and the performance of the algorithm may depend on ϵ as well as |x|. This task of outputting samples is known as _weak simulation_, while _strong simulation_ is the related function problem of outputting the output probabilities themselves.",
      "isalso":[["Function Problem","By switching from a weak simulation problem to a strong simulation problem, where inputs are pairs (x,s) and the outputs are μ(s) for (x,μ) in the original sampling problem."]]
    }
  ],
  
  "classes":[
//first are all the languages, in alphabetical order.
//non-language classes like PromiseBPP, FPT, or PPLS come after.
    {"name":"A_0PP",
     "type":"Language",
     "desc":"TODO. Defined in {ref:Vya03}.",
     "related":["PP","AWPP","SBP"]
    },
    {"name":"AC",
     "type":"Language",
     "desc":"Unbounded Fanin Polylogarithmic-Depth Circuits. The class of decision problems solvable by a nonuniform family of Boolean circuits, with polynomial size, depth O(log^k(n)), and unbounded fanin, for some k. The gates allowed are AND, OR, and NOT. For a given k, we get AC^k, such as AC^1. The class AC^0 is when k=0 i.e. constant depth. Equal to NC and TC.",
     "related":["AC^0","AC^1","NC","TC"]
    },
    {"name":"AC^0",
     "type":"Language",
     "desc":"Unbounded Fanin Constant-Depth Circuits. An especially important subclass of AC, corresponding to constant-depth, unbounded-fanin, polynomial-size circuits with AND, OR, and NOT gates.",
     "related":["AC^1","AC^0","NC^0","NC"]
    },
    {"name":"AC^1",
     "type":"Language",
     "desc":"Unboudned Fanin Log-depth Circuits.",
     "related":["AC^0","AC","TC^1","NC^1"]
    },
    {"name":"ACC^0",
     "type":"Language",
     "desc":"AC0 With Arbitrary MOD Gates.",
     "related":["AC^0","TC^0"]
    },
    {"name":"ACKERMANN",
     "type":"Language",
     "desc":"Ackermann function time. Problems solvable by a Turing machine in time A(O(n),O(n)), where A is the Ackermann function. Reachability in vector addition systems is complete for this class, placing it strictly above PR.",
     "related":["PR"]
    },
    {"name":"ALL",
     "type":"Language",
     "desc":"All languages. Everything is contained in this class. Not considered feasible.",
     "related":["R","RE"]
    },
    {"name":"AM",
     "type":"Language",
     "desc":"Arthur-Merlin games. In general, AM[k] is k-round interactive protocols between am omniscient Merlin and a polytime Arthur. Arthur has randomness, but Merlin can see all of Arthur's randomness, and they exchange polynomial size messages, and Arthur becomes convinced with 2/3 soundness and completeness. It turns out that AM[k]=AM[2] for any constant k, TODO reference, and then the class AM is defined as AM[2]. This doesn't translate to polynomial k, as the message sizes grows by at least a constant factor with each removed round, leading to exponential slowdown if you tried to run AM[poly] as a AM[2] protocol. As other cases, there are AM[0]=BPP, AM[1]=MA, and AM[poly(n)]=IP. There is also the odd one AM[polylog(n)].\n Compare with IP[k], which has private coins: Merlin can't see Arthur's random choices.",
     "related":["NP","MA","IP"],
     "notes":"todo def"
    },
    {"name":"AP",
     "type":"Language",
     "desc":"Alternating polynomial time. Polynomial time with unlimited switches between an \"NP\"-like \"OR\" mode, and a coNP \"AND\" mode.",
     "related":["PSPACE","PH"],
     "notes":"todo def"
    },
    {"name":"AWPP",
     "type":"Language",
     "desc":"TODO",
     "related":["A_0PP","SBP"]
    },

    {"name":"BPP",
     "type":"Language",
     "desc":"Bounded error Probabilistic Polynomial time. Problems with a probabilistic polynomial-time Turing machine with at least a 2/3 chance of a correct answer.",
     "related":["PromiseBPP","ZPP","RP"]
    },
    {"name":"BQP",
     "type":"Language",
     "desc":"TODO",
     "related":["BPP","EQP","QMA","IQP","NISQ"]
    },

    {"name":"CFL",
     "type":"Language",
     "desc":"Context-Free languages",
     "related":["REG"]
    },
    {"name":"CH",
     "type":"Language",
     "desc":"Counting Hierarchy. Union of PP, PP^PP, PP^(PP^PP), and so on. With the counting operator C[M] = PP^M, we can say that CH = C^O(1)[P], analogous to how PH = Σ^O(1)[P] = Π^O(1)[P]",
     "related":["PP"]
    },
    {"name":"coAM",
     "type":"Language",
     "desc":"Complement of Arthur-Merlin games",
     "related":["AM","coMA"],
     "notes":"todo def"
    },
    {"name":"coNL",
     "type":"Language",
     "desc":"Complement of Nondeterministic Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.",
     "solver":"coNSPACE(log(n))"
    },
    {"name":"coMA",
     "type":"Language",
     "desc":"Complement of Merlin-Arthur games",
     "related":["MA","coAM"],
     "notes":"todo def. todo coMA=coMA1"
    },
    {"name":"coNP",
     "type":"Language",
     "desc":"Complement of Nondeterministic Polynomial time. Problems whose complement decided in polynomial time by a nondeterministic Turing machine.",
     "solver":"coNTIME(n^O(1))",
     "notes":"todo: verifier definition"
    },
    {"name":"coRE",
     "type":"Language",
     "desc":"Complement of Recursively enumerable languages. Languages whose rejection can be recognized by a Turing machine.",
     "related":["RE"],
     "notes":"todo: definition as a Turing machine"
    },
    {"name":"coRP",
     "type":"Language",
     "desc":"Complement of Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine with zero error on YES instances",
     "related":["RP"],
     "notes":"todo: complement of RP"
    },
      
    {"name":"DET",
     "type":"Language",
     "desc":"Problems L-reducible to computing the determinant of an n-by-n matrix of n-bit integers. ComplexityZoo says the corresponding function class is GapL (TODO ref).",
     "related":["NL","NC^2"]
    },
    {"name":"DQC1",
     "type":"Language",
     "desc":"Deterministic Quantum Computing with 1 Clean Bit. The class of problems solvable by a BQP machine in which a single qubit is initialized to the '0' state, and the remaining qubits are initialized to the maximally mixed state. Defined in {ref:KL98}. This has been called BQ1P, sometimes, to distinguish it from the _sampling_ problem of DQC1 circuits. Since \"DQC1\" seems to have stuck, we call the sampling problem DQC1S.",
     "related":["BQP","DQC1S"]
    },
    {"name":"DQP",
    "type":"Language",
    "desc":"Dynamical Quantum Polynomial-Time.The class of decision problems solvable by a BQP machine with oracle access to a dynamical simulator. When given a polynomial-size quantum circuit, the simulator returns a sample from the distribution over \"classical histories\" induced by the circuit. The simulator can adversarially choose any history distribution that satisfies the axioms of \"symmetry\" and \"locality\" -- so that the DQP algorithm has to work for any distribution satisfying these axioms. Defined in {ref:Aar05}.",
    "related":["BQP"]
    },
    
    {"name":"E",
     "type":"Language",
     "desc":"(Linear) Exponential time. Problems decided in exponential time with linear exponent, by a deterministic Turing machine.",
     "solver":"DTIME(2^O(n))"
    },
    {"name":"ELEMENTARY",
     "type":"Language",
     "desc":"Elementary languages. The union of EXP, EEXP, EEXP, etc.: solvable by a Turing machine with runtime 2^n, 2^(2^n), 2^(2^(2^n)) for some height. Equivalently, DTIME(^{O(1)}n), where ^{a}b indicates the tetration of b to the height a.",
     "related":["EXP"]
    },
    {"name":"EQP",
     "type":"Language",
     "desc":"TODO",
     "related":["BQP"]
    },
    {"name":"EXP",
     "type":"Language",
     "desc":"Exponential time. Problems decided in singly exponential time by a deterministic Turing machine.",
     "solver":"DTIME(2^(n^O(1)))"
    },
    
    {"name":"GA",
     "type":"Language",
     "desc":"Graph Automorphism. Languages that can be polynomial-time Turing reduced to Graph Automorphism. Compare with GI for isomorphism, and GAK for Karp reductions.",
     "related":["GAK","GI"]
    },
    {"name":"GAK",
     "type":"Language",
     "desc":"Graph Automorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.",
     "related":["GA","GIK"]
    },
    {"name":"GI",
     "type":"Language",
     "desc":"Graph Isomorphism. Languages that can be polynomial-time Turing reduced to Graph Isomorphism. This is, in some sense, a powerful reduction; compare with GIK for Karp reductions. Compare with GA which only allows automorphism checking.",
     "related":["GIK","GA"]
    },
    {"name":"GIK",
     "type":"Language",
     "desc":"Graph Isomorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.",
     "related":["GI","GAK"]
    },
      
    {"name":"IP",
     "type":"Language",
     "desc":"Interactive Proofs. In general, IP[r] means a proof where a player exchanges r rounds with a polynomial time verifier; the verifier has private random coins. The class IP is defined as IP[poly(n)], and it turns out that IP=PSPACE, see {ref:Sha90}. For IP[r] with a constant r, it turns to be equal to AM; see AM for more. {ref:BM88} also proved that IP[f(n)]=IP[c*f(n)].",
     "related":["QIP","MIP","AM","PSPACE"]
    },

    {"name":"L",
     "type":"Language",
     "desc":"Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.",
     "solver":"DSPACE(log(n))",
     "notes":"todo SL"
    },
    {"name":"LOGCFL",
     "type":"Language",
     "desc":"The class of decision problems reducible in L to the problem of deciding membership in a context-free language. In order words, the closure under L-reductions of {lang:CFL}. Equivalently, LOGCFL is the class of decision problems solvable by a _uniform_ family of AC1 circuits, in which no AND gate has fan-in exceeding 2, see {ref:Joh90}{ref:Ven91}. When the circuits aren't uniform, we get the LOGCFL/poly = SAC^1, see {lang:SAC^1}.",
     "related":["CFL","SAC^1"]
    },

    {"name":"MA",
     "type":"Language",
     "desc":"Merlin-Arthur games",
     "related":["NP","AM","QMA"],
     "notes":"todo def. todo MA=MA1"
    },
    {"name":"MIP",
     "type":"Language",
     "desc":"Multiple-player Interactive Proofs. In general, MIP[p,r] means a proof with p player who cannot communicate, and r rounds of interaction with a referee. (The final round is always a message to the referee, as a final message to a player cannot be useful.) As it turns out, MIP[p,r]=MIP[2,1] for any p>=2 and r>=1, so the distinction is largely unnecessary. MIP[1,r] is better known as AM[r], see AM for more. \n And of course MIP[p,0] is just P. :)\n\nMIP[p,r]=MIP[2,poly] is proved in {ref:BFL91}. I can't find a source for the statement that MIP[2,poly]=MIP[2,1].",
     "related":["AM","IP","QIP","MIP*","MIPco","NEXP"]
    },
    {"name":"MIP*",
     "type":"Language",
     "desc":"Multiple-player Interactive Proofs, with entanglement. Traditionally defined with polynomially many players and rounds, but it turns out that MIP*[poly,poly]=MIP*[2,1], so one can just think of as two players and one round. \n When the provers are allowed to have (unbounded) entanglement, this allows them to cheat at some games, so it is not obvious that MIP* is as big as MIP; it is only clear that one can ignore all but one player and get the class IP as a lower bound. But, having entanglement also means we can ask more from the players -- much more, and it turns out that MIP*=RE, and includes undecidable problems.",
     "related":["MIP","MIPco","RE"]
    },
    {"name":"MIPco",
     "type":"Language",
     "desc":"Multiple-player Interactive Proofs, with entanglement, in the _commuting_ operator framework. This was expected to be equal to MIP*, but this isn't the case: MIP*=RE, while MIPco is contained in coRE. (It is expected that MIPco=coRE.) Nothing contained in coRE can equal RE!",
     "related":["coRE","MIPco","MIP*"]
    },

    {"name":"NC",
     "type":"Language",
     "desc":"Nick's Class",
     "related":["AC","TC","NC^0"]
    },
    {"name":"NC^0",
     "type":"Language",
     "desc":"Constant-Depth Nick's Class: uniform constant depth circuits with bounded-fanin gates. By definition, a decision problem in NC0 can depend on only a constant number of bits of the input. Thus, NC^0 often refers to functions computable by constant-depth, bounded-fanin circuits, as it crops up in NC^0 reduction. Here we call that class of functions FNC^0 instead.",
     "related":["AC^0","TC^0","NC^1","NC","FNC^0"]
    },
    {"name":"NC^1",
     "type":"Language",
     "desc":"Log-Depth Nick's Class",
     "related":["AC^1","TC^1","NC^0","NC"]
    },
    {"name":"NC^2",
     "type":"Language",
     "desc":"Log^2-Depth Nick's Class",
     "related":["AC^1","DET","NC"]
    },
    {"name":"NEXP",
     "type":"Language",
     "desc":"Nondeterministic Exponential Time; also called NEXPTIME. Equivalently, problems with an EXP-size witness that can be verified by a polytime verifier (whose runtime is polynomial in the size of the input *and* the witness).",
     "related":["NP","EXP"]
    },
    {"name":"NISQ",
     "type":"Language",
     "desc":"Problems solvable by a classical computer in poly(n) time with poly(n) queries to an λ-NQC oracle, which outputs samples from a λ-noisy quantum circuit: after each gate single gate, a λ-noise depolarizing channel is applied simultaneously to every qubit.",
     "related":["BQP","IQP"],
     "ref":"https://arxiv.org/pdf/2210.07234.pdf"
    },
    {"name":"NL",
     "type":"Language",
     "desc":"Nondeterministic Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.",
     "solver":"NSPACE(log(n))"
    },
    {"name":"NP",
     "type":"Language",
     "desc":"Nondeterministic Polynomial time. Problems decided in polynomial time by a nondeterministic Turing machine.",
     "solver":"NTIME(n^O(1))",
     "notes":"todo: verifier definition"
    },
    {"name":"NQP",
     "type":"Language",
     "desc":"Nondeterministic Quantum Polynomial time. The class of decision problems solvable by a QTM in polynomial time such that a particular \"|Accept>\" state has nonzero amplitude at the end of the computation, if and only if the answer is \"yes.\"",
     "related":["QMA","BQP"]
    },
    
    {"name":"P",
     "type":"Language",
     "desc":"Polynomial time. Problems decided in polynomial time by a deterministic Turing machine.",
     "solver":"DTIME(n^O(1))"
    },
    {"name":"PARITY",
     "type":"Language",
     "desc":"The single language asking, 'Is the number of 1s in the input an even number'?"
    },
    {"name":"PH",
     "type":"Language",
     "desc":"Polynomial hierarchy",
     "related":["Δ2","PP"],
     "notes":"todo"
    },
    {"name":"PP",
     "type":"Language",
     "desc":"Probabilistic Polynomial time.",
     "related":["BPP"],
     "notes":"todo"
    },
    {"name":"PR",
     "type":"Language",
     "desc":"Primitive Recursive. Languages decidable in time bounded by a primitive recursive function of natural numbers.",
     "notes":"todo define PR *functions*",
     "related":["ELEMENTARY","ACKERMANN"]
    },
    {"name":"PSPACE",
     "type":"Language",
     "desc":"Polynomial space. Problems decided in polynomial space by a deterministic Turing machine.",
     "solver":"DSPACE(n^O(1))",
     "notes":"todo NSPACE equivalence",
     "related":["AP","PH"]
    },
    
    {"name":"QCMA",
     "type":"Language",
     "desc":"Quantum-Classical Merlin-Arthur. Like QMA, but Merlin's proof is a classical string; like NP, but the verifier has a quantum computer (BQP machine).",
     "related":["QMA"]
    },
    {"name":"QIP",
     "type":"Language",
     "desc":"Quantum Interactive Proofs. Like IP, but now messages can be quanutum. Only a single prover. For a different kind of 'quantum' interactive proof, there's the much harder MIP* and MIPco.",
     "related":["IP","MIP*","MIPco"]
    },
    {"name":"QMA",
     "type":"Language",
     "desc":"Quantum Merlin-Arthur. Problems for which an omniscient 'Merlin' can submit a proof to 'Arthur' that a statement is true, and Arthur believes it with high probability (<1/3 chance of failing) -- but this proof can be a quantum state, and Arthur has a quantum computer.",
     "related":["QCMA","BQP"]
    },
    {"name":"QNC",
      "type":"Language",
      "desc":"The class of decision problems solvable by polylogarithmic-depth quantum circuits with bounded probability of error. The zoo says, \"A uniformity condition may also be imposed.\"; for the purpose of this site we _do_ impose that condition. Some sources like https://dl.acm.org/doi/10.1145/3570637 refer to this as BQNC.",
      "related":["RNC","NC","BQP"]
    },
    {"name":"QNC^0",
      "type":"Language",
      "desc":"Constant-depth quantum circuits",
      "related":["QNC","QNC^0"]
    },
    {"name":"QNC^1",
      "type":"Language",
      "desc":"Log-depth quantum circuits",
      "related":["QNC^0","QNC"]
    },
    
    {"name":"R",
     "type":"Language",
     "desc":"Recursive languages. RE∩coRE. Languages solvable by a Turing machine.",
     "related":["RE"],
     "notes":"todo: definition as a Turing machine, definition as intersection"
    },
    {"name":"RE",
     "type":"Language",
     "desc":"Recursively enumerable languages. Languages whose acceptance can be recognized by a Turing machine.",
     "related":["R"],
     "notes":"todo: definition as a Turing machine"
    },
    {"name":"REG",
     "type":"Language",
     "desc":"Regular languages",
     "related":["CFL"]
    },
    {"name":"RL",
     "type":"Language",
     "desc":"Randomized Logspace. Problems with a probabilistic logarithmic-space Turing machine with zero error on NO instances (and, technically, a termination probability of 1 on all inputs).",
     "related":["NL","L","RP"],
     "notes":"todo: complement of coRL"
    },
    {"name":"RP",
     "type":"Language",
     "desc":"Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine with zero error on NO instances",
     "related":["coRP","ZPP","BPP"],
     "notes":"todo: complement of coRP"
    },
    {"name":"RNC",
     "type":"Language",
     "desc":"Randomized Nick's Class. The class of decision problems solvable by polylogarithmic-depth random circuits with bounded one-sided probability of error: it must never incorrectly accept, and it must correctly reject at least 1/2 of the time.",
     "related":["NC","RP","QNC"],
     "notes":"todo: complement of coRNC"
    },
    {"name":"RNC^0",
     "type":"Language",
     "desc":"Randomized constant-depth circuits of bounded-fanin. Not very interesting because the randomness cannot be useful, so this is equal to NC^0. But the functional version FRNC^0 is slightly more interesting (in the same way that FNC^0 is more interesting than NC^0) and has been used in reductions, e.g. https://drops.dagstuhl.de/opus/volltexte/2023/17506/pdf/LIPIcs-ITCS-2023-3.pdf",
     "related":["RNC","RNC^1"]
    },
    {"name":"RNC^1",
     "type":"Language",
     "desc":"Randomized log-depth circuits of bounded-fanin.",
     "related":["RNC","RNC^0"]
    },
      
    {"name":"SAC^0",
     "type":"Language",
     "desc":"SAC^k is the class of decision problems solvable by a family of depth-O(logkn) circuits with unbounded-fanin OR & bounded-fanin AND gates. Negations are only allowed at the input level. A uniformity condition may also be imposed. SAC^k sits naturally 'halfway' between NC^k and AC^k.",
     "related":["SAC^1","AC^0"]
    },
    {"name":"SAC^1",
     "type":"Language",
     "desc":"Semi-Unbounded-Fanin AC^1. See {ref:SAC^0} for definition. SAC^1 (with a uniformity condition) = LOGCFL, and without a uniformity condition = LOGCFL/poly, see {ref:Joh90}{ref:Ven91}.",
     "related":["SAC^0","AC^1","LOGCFL"]
    },
    {"name":"SBP",
     "type":"Language",
     "desc":"Small Bounded-Error Probability. The class of decision problems for which the following holds. There exists a #P function f and an FP function g such that, for all inputs x,\n If the answer is \"yes\" then f(x) > g(x).\n If the answer is \"no\" then f(x) < g(x)/2.\n Defined in {ref:BGM02}.",
     "related":["AM","MA","AWPP","A_0PP"],
     "notes":"TODO closed under union, ref BGM02."
    },
    {"name":"SF",
     "type":"Language",
     "desc":"Star-free languages, see https://en.wikipedia.org/wiki/Star-free_language. A subset of regular languages, where constant terms are allowed, and then we take the closure under complementation, union, and concatenation. Intersection comes for free. For example, the regex (ab)* is in this class, but (aa)* is not.",
     "related":["REG"]
    },
    {"name":"SZK",
     "type":"Language",
     "desc":"Statistical Zero Knowledge.",
     "related":[],
     "notes":"todo def"
    },
      
    {"name":"TC",
     "type":"Language",
     "desc":"Threshold Circuits",
     "related":["AC","NC","TC^0"]
    },
    {"name":"TC^0",
     "type":"Language",
     "desc":"Constant-Depth Threshold Circuits",
     "related":["AC^0","ACC^0","NC^0","TC"]
    },
    {"name":"TC^1",
     "type":"Language",
     "desc":"Log-Depth Threshold Circuits",
     "related":["AC^1","NC^0","TC^0","TC"]
    },
    {"name":"TOWER",
     "type":"Language",
     "desc":"Power-tower time. Solvable in time f(x), where f can be expressed using tetration (and +, *, ^, 0, 1).",
     "related":["ELEMENTARY","PR"]
    },
    
    {"name":"ZPP",
     "type":"Language",
     "desc":"Zero error Probabilistic Polynomial time. Problems with a probabilistic Turing machine with zero error and polynomial expected running time",
     "related":["BPP","RP"],
     "notes":"todo the polytime yes/no/unknown definition. todo the two-machine definition"
    },
    
    {"name":"Δ2",
     "type":"Language",
     "desc":"P^NP. The weakest class at the second level in the polynomial hierarchy.",
     "solver":"P^NP",
     "related":["Π2","Σ2","PH"]
    },
    {"name":"Π2",
     "type":"Language",
     "desc":"Universal polynomial time, 2 alternations. coNP^NP, at the second level in the polynomial hierarchy.",
     "solver":"coNP^NP",
     "related":["Δ2","Σ2","PH"]
    },
    {"name":"Σ2",
     "type":"Language",
     "desc":"Existential polynomial time, 2 alternations. NP^coNP, at the second level in the polynomial hierarchy.",
     "solver":"NP^coNP",
     "related":["Π2","Δ2","PH"]
    },

//promise problems
    {"name":"PromiseRP",
     "type":"Promise Problem",
     "desc":"Promise Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine promised to have at least a 1/2 chance rejecting correctly (and that always accept).",
     "related":["RP"]
    },
    {"name":"PromiseBPP",
     "type":"Promise Problem",
     "desc":"Promise Bounded error Probabilistic Polynomial time. Problems with a probabilistic polynomial-time Turing machine promised to have at least a 2/3 chance of a correct answer.",
     "related":["BPP"]
    },
    {"name":"PromiseMA",
     "type":"Promise Problem",
     "desc":"Promise Merlin Arthur. Like MA, but with a promise on the acceptance probabilities.",
     "related":["MA"]
    },
    {"name":"PromiseBQP",
     "type":"Promise Problem",
     "desc":"Promise Bounded error Quantum Polynomial time. Like BQP, but with a promise on the acceptance probabilities",
     "related":["MA"]
    },
    {"name":"PromiseQCMA",
     "type":"Promise Problem",
     "desc":"Promise Quantum-Classical Merlin Arthur. Like QCMA, but with a promise on the acceptance probabilities",
     "related":["QCMA"]
    },
    {"name":"PromiseQMA",
     "type":"Promise Problem",
     "desc":"Promise Quantum Merlin Arthur. Like QMA, but with a promise on the acceptance probabilities",
     "related":["QMA"]
    },

//function problems
    {"name":"TFNP",
     "type":"Function Problem",
     "desc":"Total Function Nondeterministic Polynomial time. Relations that can be checked by deterministic polynomial time machine.",
     "related":["NP","FNP"]
    },
    {"name":"FNP",
     "type":"Function Problem",
     "desc":"Function Nondeterministic Polynomial time.",
     "related":["TFNP","NP"],
     "notes":"todo def"
    },
    {"name":"FNC^0",
     "type":"Function Problem",
     "desc":"Function Constant-Depth circuits with bounded-fanin. Each output bit depends on only a constant number of input bits. Function equivalently of NC^0, and used in reductions.",
     "related":["NC^0"]
    },

//parameterized complexity
    //There's a wide variety more classes and discussions of these classes at
       // https://www.mimuw.edu.pl/~malcin/book/parameterized-algorithms.pdf
       // http://satsmt2013.ics.aalto.fi/slides/Szeider.pdf
       // https://www.sciencedirect.com/science/article/pii/S0022000017300089
       // https://www.mdpi.com/1999-4893/12/9/188
       // http://www.tcs.uni-luebeck.de/downloads/mitarbeiter/tantau/2013-hannover.pdf
       // https://www.zhb.uni-luebeck.de/epubs/ediss1780.pdf
       // https://arxiv.org/pdf/1509.06984.pdf
    {"name":"para-L",
     "type":"Parameterized Language",
     "desc":"Parameterized Logspace. Languages (x,k) with a deterministic algorithm running in space f(k)+O(log(n)).",
     "related":["para-NL","XL"]
    },
    {"name":"para-NL",
     "type":"Parameterized Language",
     "desc":"Parameterized Nondeterministic Logspace. Languages (x,k) with a nondeterministic algorithm running in space f(k)+O(log(n)).",
     "related":["para-L","XNL"]
    },
    {"name":"FPT",
     "type":"Parameterized Language",
     "desc":"Fixed Parameter Tractable. Languages (x,k) with a deterministic algorithm running in time n^{O(1)}*f(k).",
     "related":["XP","W[1]"],
     "alias":"para-P"
    },
    {"name":"W[1]",
     "type":"Parameterized Language",
     "desc":"Weft-1 circuits.",
     "related":["XP","FPT","W[2]","W[P]"],
     "notes":"todo def"
    },
    {"name":"W[2]",
     "type":"Parameterized Language",
     "desc":"Weft-2 circuits.",
     "related":["XP","FPT","W[1]","W[P]"],
     "notes":"todo def"
    },
    {"name":"W[P]",
     "type":"Parameterized Language",
     "desc":"Polynomial Weft circuits. Equivalently, problems with a witness that can be verified by a polynomial-time machine (an unparameterized polynomial time, n^{O(1)}, in the size of the input and witness), with a witness of size f(k)*O(log(n)). Compare with para-NP, XP, which are also a version of parameterized nondeterminism.",
     "related":["W[1]","XP","FPT","para-NP"],
     "notes":"todo def"
    },
    {"name":"para-NP",
     "type":"Parameterized Language",
     "desc":"Parameterized NP. Languages (x,k) with a nondeterministic algorithm running in time f(k)*n^{O(1)}. Equivalently, problems with a deterministic polynomial-time verifier that take a problem and witness, and the witness is of size f(k)*n^{O(1)}. A classic example is k-coloring: it's in NP for any k, and fixing k at a low value (such as 3) leaves it difficult. Since k-coloring is atually para-NP-hard too, it's para-NP-complete. Compare with XNP, where the exponent of the machine is allowed to depend on k.",
     "related":["XP","NP","XNP"]
    },
    {"name":"XL",
     "type":"Parameterized Language",
     "desc":"Slicewise Logspace. Languages (x,k) with a deterministic algorithm running in space f(k)*log(n).",
     "related":["W[1]","FPT"]
    },
    {"name":"XNL",
     "type":"Parameterized Language",
     "desc":"Slicewise Nondeterministic Logspace. Languages (x,k) with a nondeterministic algorithm running in space f(k)*log(n).",
     "related":["XL","XP"]
    },
    {"name":"XP",
     "type":"Parameterized Language",
     "desc":"Slicewise Polynomial time. Languages (x,k) with a deterministic algorithm running in time n^f(k).",
     "related":["W[1]","FPT"]
    },
    {"name":"XNP",
     "type":"Parameterized Language",
     "desc":"Slicewise NP. Languages (x,k) with a nondeterministic algorithm running in time n^f(k). Equivalently, problems with witnesses of size n^{f(k)} with a polynomial-time verifier.",
     "related":["para-NP","XP"]
    },
    {"name":"Kernel",
     "type":"Parameterized Language",
     "desc":"Problems that admit kernelization: languages (x,k) for which there is a _kernelization algorithm_ that processes the original instance in time poly(n,k) = (n+k)^{O(1)}, and produces an output string K of size f(k) for a computable function f, so that the original instance can be decided by running some (computable) algorithm on K. See [Wikipedia](https://en.wikipedia.org/wiki/Kernelization#Downey%E2%80%93Fellows_notation) for more details. This is a stronger requirement than being FPT, by essentially saying that the \"slow\" part of the algorithm that depends on k shouldn't need the whole input.",
     "related":["FPT"]
    },

//sampling problems
    {"name":"IQP",
     "type":"Sampling Problem",
     "desc":"TODO",
     "related":["BQP","NISQ"]
    },
    {"name":"DQC1S",
     "type":"Sampling Problem",
     "desc":"Sampling Deterministic Quantum Computing with 1 Clean Bit. Samples produced from a quantum computer initialized with one qubit in the zero state and everything else in the maximally mixed state. Sampling version of DQC1, see there for more.",
     "related":["DQC1"]
    }
  ],
  
  "conjectures":[
    {"name":"P!=NP",
     "content":"P⊂NP",
     "implies":["P!=PSPACE"]
    },
    {"name":"P!=PSPACE",
     "content":"P⊂PSPACE",
     "implies":[]
    },
    {"name":"P=BPP",
     "content":"P=BPP",
     "implies":[]
    }
  ],
  
  "theorems":[
    
//Metatheorems. The relevant reified consequences are given immediately below.
    {"name":"Deterministic space hierarchy theorem",
     "ref":"https://en.wikipedia.org/wiki/Space_hierarchy_theorem",
     "content":"{f}SpaceConstructible(f)⟹(DSPACE(f)⊃DSPACE(o(f)))",
     "related":["Nondeterministic space hierarchy theorem"]
    },
            {"name":"L⊂PSPACE",
             "content":"L⊂PSPACE",
             "impliedby":"Deterministic space hierarchy theorem"
            },
    {"name":"Nondeterministic space hierarchy theorem",
     "ref":"https://en.wikipedia.org/wiki/Space_hierarchy_theorem",
     "content":"{f}SpaceConstructible(f)⟹(NSPACE(f)⊃NSPACE(o(f)))",
     "related":["Deterministic space hierarchy theorem"]
    },
    {"name":"Deterministic time hierarchy theorem",
     "ref":"https://en.wikipedia.org/wiki/Time_hierarchy_theorem",
     "content":"{f}TimeConstructible(f)⟹(DTIME(o(f/log(f)))⊃DTIME(f))",
     "related":["Nondeterministic time hierarchy theorem"]
    },
            {"name":"P⊂E",
             "content":"P⊂E",
             "impliedby":"Deterministic time hierarchy theorem"
            },
            {"name":"E⊂EXP",
             "content":"E⊂EXP",
             "impliedby":"Deterministic time hierarchy theorem"
            },
    {"name":"Noneterministic time hierarchy theorem",
     "ref":"https://en.wikipedia.org/wiki/Time_hierarchy_theorem",
     "content":"{f}TimeConstructible(f)⟹(NTIME(f)⊂NTIME(f^2))",
     "related":["Deterministic time hierarchy theorem"],
     "notes":"todo stronger statement -- currently not as tight as could be"
    },
    {"name":"Time-bounded padding argument",
     "ref":"https://en.wikipedia.org/wiki/Padding_argument",
     "content":"{f,g,h}TimeConstructible(f)&&TimeConstructible(g)&&h≥n&&(NTIME(f)⊆DTIME(g))⟹(NTIME(h(f))⊆DTIME(h(g)))"
    },
    {"name":"Space-bounded padding argument",
     "ref":"https://en.wikipedia.org/wiki/Padding_argument",
     "content":"{f,g,h}SpaceConstructible(f)&&SpaceConstructible(g)&&h≥n&&(NSPACE(f)⊆DSPACE(g))⟹(NSPACE(h(f))⊆DSPACE(h(g)))",
     "notes":"https://en.wikipedia.org/wiki/Immerman%E2%80%93Szelepcs%C3%A9nyi_theorem#cite_note-1"
    },
    
//Classic named theorems
    {"name":"Immerman–Szelepcsényi theorem",
     "ref":"https://en.wikipedia.org/wiki/Immerman%E2%80%93Szelepcs%C3%A9nyi_theorem",
     "content":"{f}(f≥log)⟹(NSPACE(f)=coNSPACE(f))"
    },
            {"name":"NL=coNL",
             "content":"NL=coNL",
             "impliedby":"Immerman–Szelepcsényi theorem"
            },
    {"name":"Savitch's theorem",
     "ref":"https://en.wikipedia.org/wiki/Savitch%27s_theorem",
     "content":"{f}(f≥log)⟹(NSPACE(f)⊆DSPACE(f^2)"
    },
    {"name":"Sipser–Lautemann theorem",
     "ref":"https://en.wikipedia.org/wiki/Sipser%E2%80%93Lautemann_theorem",
     "content":"BPP⊆Σ2&&BPP⊆Π2"
    },
    
//Nontrivial results - the real meat!
    {"name":"QMA⊆PP",
     "content":"QMA⊆PP",
     "ref":"C. Marriott and J. Watrous. Quantum Arthur-Merlin Games, Computational Complexity, 14(2):122-152, 2005. doi:10.1007/s00037-005-0194-x.\n [MW05] at https://complexityzoo.net/Complexity_Zoo_References#mw05",
     "notes":"todo"
    },
    {"name":"AM⊆Π2",
     "content":"AM⊆Π2",
     "notes":"Can't find a reference for this but also not obvious to me. (Maybe it should be obvious?)"
    },
            {"name":"coAM⊆Σ2",
             "content":"coAM⊆Σ2",
             "impliedby":"AM⊆Π2",
             "ref":"Implied by {thm:AM⊆Π2} by taking complements"
            },
    {"name":"GA⊆GI",
     "content":"GA⊆GI",
     "ref":"Proved in https://complexityzoo.net/Complexity_Zoo_References#kst93. Pretty simple proof but not manifest from the definition; compare with GAK vs GIK where the question isn't settled."
    },
    {"name":"GIK⊆SZK",
     "content":"GIK⊆SZK",
     "ref":"Classic Graph Nonisomorphism protocol for Statistical Zero Knowledge, combined with SZK closed under complement."
    },
    {"name":"SZK⊆coAM",
     "content":"SZK⊆coAM",
     "ref":"SZK⊆AM, combined with SZK is closed under complement."
    },
    {"name":"NC^1⊆L",
     "content":"NC^1⊆L",
     "ref":"Proved in {ref:Bor77}"
    },
    {"name":"DET⊆NC^2",
     "content":"DET⊆NC^2",
     "ref":"TODO"
    },
    {"name":"NL⊆DET",
     "content":"NL⊆DET",
     "ref":"TODO"
    },
    {"name":"NL⊆AC^1",
     "content":"NL⊆AC^1",
     "ref":"TODO"
    },
    {"name":"AP=PSPACE",
     "content":"AP=PSPACE",
     "ref":"{ref:CKS81}"
    },
    {"name":"SZK⊆DQP",
     "content":"SZK⊆DQP",
     "ref":"{ref:Aar05}"
    },
    {"name":"DQP⊆EXP",
     "content":"DQP⊆EXP",
     "ref":"{ref:Aar05}"
    },
    {"name":"L⊆DQC1",
     "content":"L⊆DQC1",
     "ref":"https://arxiv.org/abs/quant-ph/0608132 shows that the one clean qubit can be magnified to log(n) clean qubits without changing the class, so any computation in quantum logspace (without measurements) is in DQC1. This includes all reversible logspace, which is equal to deterministic logspace, see Lange, McKenzie and Tapp [LMT00]."
    },
    {"name":"SF⊆AC^0",
     "content":"SF⊆AC^0" ,
     "ref":"Stated without reference on Wikipedia: https://en.wikipedia.org/wiki/Star-free_language"
    },
    {"name":"CFL⊆NP",
     "content":"CFL⊆NP" ,
     "ref":"This is the characterization that CFLs are recognized by (nondeterministic) pushdown automata. Can be tightened to NLIN, TODO add that class. TODO add that DCL is in P, specifically in LIN."
    },
    {"name":"PARITY⊈AC^0",
     "content":"PARITY⊈AC^0",
     "ref":"PARITY, the one-language class of recognizing the parity of a string, cannot be computed by an AC^0 circuit. The same is true for any mod-m parity problem. See {ref:Raz87}{ref:Smo87}."
    },
    {"name":"ACC^0⊂PP",
     "content":"ACC^0⊂PP" ,
     "ref":"{ref:AG95}"
    },
    {"name":"ACC^0⊂E",
     "content":"ACC^0⊂E" ,
     "ref":"{ref:Wil11}"
    },
    {"name":"ACC^0⊂NQP",
     "content":"ACC^0⊂NQP",
     "ref":"{ref:MW18}"
    },
    {"name":"LOGCFL=SAC^1",
     "content":"LOGCFL=SAC^1",
     "ref":"Mentioned in {ref:Joh90}{ref:Ven91}, don't know where it was actually proved.",
     "notes":"Technically LOGCFL = uniform-SAC^1, and LOGCFL/poly = SAC^1. Got to make this more precise."
    },
    {"name":"IP=PSPACE",
     "content":"PSPACE⊆IP",
     "ref":"Proved in {ref:Sha90}. The other direction, that IP⊆PSPACE and so IP=PSPACE, from a simulation argument -- see {thm:IP⊆PSPACE}."
    },
    {"name":"MIP=NEXP",
     "content":"MIP=NEXP",
     "ref":"{ref:BFL91}"
    },
    {"name":"MIP*=RE",
     "content":"MIP*=RE",
     "ref":"{ref:JNVWY20}"
    },
    {"name":"NEXP⊆MIPco",
     "content":"NEXP⊆MIPco",
     "ref":"{ref:Lin23}"
    },
    {"name":"MIPco⊆coRE",
     "content":"MIPco⊆coRE",
     "ref":"A consequence of {ref:NPA08}, as they give a hierarchy that converges to the MIPco value of a game from one above. This is contrast to MIP*, where trying gradually larger Hilbert spaces converges from below, so it is contained in RE."
    },
    {"name":"IP⊆PSPACE",
     "content":"IP⊆PSPACE",
     "ref":"This is often stated as a simple protocol simulation question, but this misses the fact that IP has private coins, and the protocol simulation approach requires public coins. See the discussion [here](https://cs.stackexchange.com/q/162804/11900). Taking the protocol simulation as the 'easy' step, this was really proved in {ref:GS86} where they showed the equivalence between private and public coins.\nTODO: Technically they show that IP[f]⊆AM[f+2] for all f(n). Then since AM[f]⊆IP[f], and AM[poly]⊆PSPACE by simulation, IP=IP[poly]⊆AM[poly]⊆PSPACE."
    },
    {"name":"QIP⊆PSPACE",
     "content":"QIP⊆PSPACE",
     "ref":"{ref:JJUW09}"
    },
    {"name":"NQP⊆PSPACE",
     "content":"NQP⊆PSPACE",
     "ref":"Strong simulation of quantum circuits in PSPACE.",
     "notes":"TODO find a reference for the strong simulation."
    },
    {"name":"NQP⊆A_0PP",
     "content":"NQP⊆A_0PP",
     "ref":"{ref:Vya03}"
    },
    {"name":"QMA⊆A_0PP",
     "content":"QMA⊆A_0PP",
     "ref":"{ref:Vya03}."
    },
    {"name":"AWPP⊆A_0PP",
     "content":"AWPP⊆A_0PP",
     "ref":"{ref:Vya03}. Is this obvious? Not sure..."
    },
    {"name":"A_0PP⊆PP",
     "content":"A_0PP⊆PP",
     "ref":"{ref:Vya03}.",
     "notes":"It is possible this proof is very simple and should be marked as 'obvious', I haven't looked at it yet."
    },
      
    {"name":"BQP⊆AWPP",
     "content":"BQP⊆AWPP",
     "ref":"{ref:FR98}."
    },
      
    {"name":"MA⊆SBP",
     "content":"MA⊆SBP",
     "ref":"{ref:BGM02}."
    },
    {"name":"SBP⊆AM",
     "content":"SBP⊆AM",
     "ref":"{ref:BGM02}."
    },
    //From zoo:
    // SBP contains WAPP, and ∃BPP.
    // SBP is contained in AM and BPPpath.
    // There exists an oracle relative to which SBP is not contained in Σ2P.

//Very simple results that still don't follow immediately from definitions
    {"name":"NC^0⊂AC^0",
     "content":"NC^0⊂AC^0",
     "ref":"NC^0 circuits can only depend on constantly many input bits, so misses classes such as the OR of all inputs."
    },
    {"name":"AC^i⊆NC^{i+1}",
     "content":"{i}AC(i)⊆NC(i+1)",
     "ref":"NC^{i+1} allows an additional factor of log(n) on the depth of the circuit. An unbounded fan-in OR gate from an AC^i circuit can be turned into a log(n) depth pattern of 2-fan-in OR gates to turn an AC^i circuit into NC^{i+1} at the expnese of a factor of log(n)"
    },
            {"name":"AC^0⊆NC^1",
             "content":"AC^0⊆NC^1",
             "impliedby":"AC^i⊆NC^{i+1}"
            },
            {"name":"AC^1⊆NC^2",
             "content":"AC^1⊆NC^2",
             "impliedby":"AC^i⊆NC^{i+1}"
            },
    {"name":"TC^i⊆NC^{i+1}",
     "content":"{i}TC(i)⊆NC(i+1)",
     "ref":"NC^{i+1} allows an additional factor of log(n) on the depth of the circuit. An unbounded fan-in OR gate or THRESHOLD gate from a TC^i circuit can be turned into a log(n) depth pattern of 2-fan-in OR gates to turn an TC^i circuit into NC^{i+1} at the expnese of a factor of log(n)."
    },
            {"name":"TC^0⊆NC^1",
             "content":"TC^0⊆NC^1",
             "impliedby":"AC^i⊆NC^{i+1}"
            },
            {"name":"TC^1⊆NC^2",
             "content":"TC^1⊆NC^2",
             "impliedby":"TC^i⊆NC^{i+1}"
            },
            {"name":"AC=NC=TC",
             "content":"AC=NC&&NC=TC",
             "ref":"Given that {thm:TC^i⊆NC^{i+1}}, and {thm:NC^i⊆SAC^i⊆AC^i⊆ACC^i&&AC^i⊆TC^i}, and NC/AC/TC are each unions of their hierarchies, these hierarchies must be equal.",
             "impliedby":"TC^i⊆NC^{i+1}"
            },
     
    {"name":"RNC^0=NC^0",
     "content":"RNC^0=NC^0",
     "ref":"An RNC^0 circuit has constant depth and bounded-fanin, therefore constant size. Therefore it has a constant number of random bits it could use, and we can just make exponentially many copies of the circuit from each random bit and take the AND of all of them. This makes it deterministic and keeps it constant size."
    },
    {"name":"NC⊆P",
     "content":"NC⊆P",
     "ref":"An NC circuit is defined to only have polynomial size, and the circuit must be generated by a logspace machine, therefore a P machine can write out the circuit and then simulate it."
    },
    {"name":"NL⊆P",
     "content":"NL⊆P",
     "ref":"There are only polynomially many states for an NL machine, and a P machine can enumerate all of them and check for a path."
    },
    {"name":"REG⊆NC^1",
     "content":"REG⊆NC^1",
     "ref":"Given a DFA for a regular language, recursively compute the transition function induced by words of size 1, then size 2, size 4, 8, etc. until you've computed the transition function induced by the full input. Accept if that function maps the initial state to the final state. This is elaborated [here](https://cs.stackexchange.com/a/74511/11900)."
    },
    {"name":"ACC^i⊆TC^i",
     "content":"{i}ACC^i⊆TC^i",
     "ref":"ACC has 'mod m' gates while TC has threshold gates. A 'w' treshold gate and a 'w+1' threshold gate let you build an 'equals w' threshold gate in constant depth. A mod m gate with n inputs can be decomposed into an OR of floor(n/m) many equality gates, so an ACC^i circuit can be mapped to a TC^i circuit with only a constant factor increase in depth and an O(n) increase in size. See for instance [here](https://cs.stackexchange.com/a/85656/11900)"
    },
            {"name":"ACC^0⊆TC^0",
             "content":"ACC^0⊆TC^0",
             "impliedby":"ACC^i⊆TC^i"
            },
    
//Lists of inclusions manifestly clear from the definitions of the two classes. "Clear" is of course subjective,
//but the idea is: can an intelligent person who reasonably understands how both classes are defined, quickly see why
//one is a relaxation of the other, without needing to find gadgets or constructions?
    
    
    {"name":"ProtocolSimulation",
     "content":"",
     "ref":"Placeholder theorem for the general argument that a public-coin interactive protocol can be simulated by a single 'player' with sufficient time and space. To be precise, if a protocol involves r rounds of classical (resp. quantum) messages of size m between an omniscient prover and M-machine verifier, then this protocol can be simulated with `r*m` classical (resp. quantum) space, plus however much memory is needed to simulate the M-machine. This implies that all of NP, coNP, MA, AM are in PSPACE, and QCMA and QMA are in BQPSPACE (which equals PSPACE); and analogous statements, that for instance coNEXP is in EXPSPACE. It does not apply to private-coin protocols like IP, MIP, or QIP, although these often turn out to be equivalent to their private-coin variants anyway."
    },
            {"name":"NP⊆PSPACE",
             "content":"NP⊆PSPACE",
             "impliedby":"ProtocolSimulation"
            },
            {"name":"coNP⊆PSPACE",
             "content":"coNP⊆PSPACE",
             "impliedby":"ProtocolSimulation"
            },
            {"name":"MA⊆PSPACE",
             "content":"MA⊆PSPACE",
             "impliedby":"ProtocolSimulation"
            },
            {"name":"AM⊆PSPACE",
             "content":"AM⊆PSPACE",
             "impliedby":"ProtocolSimulation"
            },
            {"name":"QCMA⊆PSPACE",
             "content":"QCMA⊆PSPACE",
             "impliedby":"ProtocolSimulation"
            },
            {"name":"QMA⊆PSPACE",
             "content":"QMA⊆PSPACE",
             "impliedby":"ProtocolSimulation"
            },
    
    //Natural 'hierarchy' theorems. Currently here: NC^i, AC^i, ACC^i, TC^i, RNC^i, QNC^i, and the PH. 
    {"name":"NC^i⊆NC^{i+1}⊆NC",
     "content":"{i}NC^i⊆NC^(i+1)⊆NC",
     "impliedby":"ObviousConstruction"
    },
            {"name":"NC^0⊆NC^1&&NC^1⊆NC^2&&NC^2⊆NC",
             "content":"NC^0⊆NC^1&&NC^1⊆NC^2&&NC^2⊆NC",
             "impliedby":"NC^i⊆NC^{i+1}⊆NC"
            },
      
    {"name":"AC^i⊆AC^{i+1}⊆AC",
     "content":"{i}AC^i⊆AC^(i+1)⊆AC",
     "impliedby":"ObviousConstruction"
    },
            {"name":"AC^0⊆AC^1&&AC^1⊆AC",
             "content":"AC^0⊆AC^1&&AC^1⊆AC",
             "impliedby":"AC^i⊆AC^{i+1}⊆AC"
            },
      
    {"name":"ACC^i⊆ACC^{i+1}⊆ACC",
     "content":"{i}ACC^i⊆ACC^(i+1)⊆ACC",
     "impliedby":"ObviousConstruction"
    },
            //We don't actually have ACC^i or ACC in the database for any i>0. ACC=AC so isn't talked about, and ACC^1
            //isn't majorly important.
            //{"name":"ACC^0⊆ACC",
            // "content":"ACC^0⊆ACC",
            // "impliedby":"ACC^i⊆ACC^{i+1}⊆ACC"
            //},
     
    {"name":"TC^i⊆TC^{i+1}⊆TC",
     "content":"{i}TC^i⊆TC^(i+1)⊆TC",
     "impliedby":"ObviousConstruction"
    },
            {"name":"TC^0⊆TC^1&&TC^1⊆TC",
             "content":"TC^0⊆TC^1&&TC^1⊆TC",
             "impliedby":"TC^i⊆TC^{i+1}⊆TC"
            },
      
    {"name":"RNC^i⊆RNC^{i+1}⊆RNC",
     "content":"{i}RNC^i⊆RNC^(i+1)⊆RNC",
     "impliedby":"ObviousConstruction"
    },
            {"name":"RNC^0⊆RNC^1&&RNC^1⊆RNC",
             "content":"RNC^0⊆RNC^1&&RNC^1⊆RNC",
             "impliedby":"RNC^i⊆RNC^{i+1}⊆RNC"
            },
      
    {"name":"QNC^i⊆QNC^{i+1}⊆QNC",
     "content":"{i}QNC^i⊆QNC^(i+1)⊆QNC",
     "impliedby":"ObviousConstruction"
    },
            {"name":"QNC^0⊆QNC^1&&QNC^1⊆QNC",
             "content":"QNC^0⊆QNC^1&&QNC^1⊆QNC",
             "impliedby":"QNC^i⊆QNC^{i+1}⊆QNC"
            },
     
    {"name":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH",
     "content":"{i}Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH",
     "impiedby":"ObviousConstruction"},
            {"name":"P⊆NP",
             "content":"P⊆NP",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"P⊆coNP",
             "content":"P⊆coNP",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"NP⊆Δ2",
             "content":"NP⊆Δ2",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"coNP⊆Δ2",
             "content":"coNP⊆Δ2",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"Δ2⊆Σ2",
             "content":"Δ2⊆Σ2",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"Δ2⊆Π2",
             "content":"Δ2⊆Π2",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"Π2⊆PH",
             "content":"Π2⊆PH",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
            {"name":"Σ2⊆PH",
             "content":"Σ2⊆PH",
             "impliedby":"P=Δ0⊆Δi⊆Πi∩Σi⊆Σi∪Πi⊆Δ{i+1}⊆PH"
            },
      
    //Circuit hierarchies have a natural ordering by adding more gates
    {"name":"NC^i⊆SAC^i⊆AC^i⊆ACC^i&&AC^i⊆TC^i",
     "content":"{i}NC^i⊆AC^i&&{i}AC^i⊆TC^i",
     "desc":"SAC is just NC together with unbounded fan-in OR, AC is just SAC with unbounded fan-in AND, ACC is just AC with mod gates, and TC is just AC together with threshold gates. TC includes ACC but this is less obvious, see {ref:ACC^i⊆TC^i}.",
     "impliedby":"ObviousConstruction"
    },
            {"name":"NC^0⊆SAC^0⊆AC^0⊆TC^0",
             "content":"NC^0⊆SAC^0&&SAC^0⊆AC^0&&AC^0⊆TC^0",
             "impliedby":"NC^i⊆SAC^i⊆AC^i⊆ACC^i&&AC^i⊆TC^i"
            },
            {"name":"NC^1⊆SAC^1⊆AC^1⊆TC^1",
             "content":"NC^1⊆SAC^1&&SAC^1⊆AC^1&&AC^1⊆TC^1",
             "impliedby":"NC^i⊆SAC^i⊆AC^i⊆ACC^i&&AC^i⊆TC^i"
            },
            {"name":"NC⊆AC⊆TC",
             "content":"NC⊆AC&&AC⊆TC",
             "impliedby":"NC^i⊆SAC^i⊆AC^i⊆ACC^i&&AC^i⊆TC^i"
            },
            {"name":"AC^0⊆ACC^0",
             "content":"AC^0⊆ACC^0",
             "impliedby":"NC^i⊆SAC^i⊆AC^i⊆ACC^i&&AC^i⊆TC^i"
            },
    
    {"name":"NC^i⊆RNC^i⊆QNC^i",
     "content":"{i}NC^i⊆AC^i&&{i}AC^i⊆TC^i",
     "desc":"RNC is just NC together with randomness, and QNC is just RNC together coherent quantum states.",
     "impliedby":"ObviousConstruction"
    },
            {"name":"NC^0⊆RNC^0⊆QNC^0",
             "content":"NC^0⊆RNC^0&&RNC^0⊆QNC^0",
             "impliedby":"NC^i⊆RNC^i⊆QNC^i"
            },
            {"name":"NC^1⊆RNC^1⊆QNC^1",
             "content":"NC^1⊆RNC^1&&RNC^1⊆QNC^1",
             "impliedby":"NC^i⊆RNC^i⊆QNC^i"
            },
            {"name":"NC⊆RNC⊆QNC",
             "content":"NC⊆RNC&&RNC⊆QNC",
             "impliedby":"NC^i⊆RNC^i⊆QNC^i"
            },
     
    {"name":"PARITY⊂ACC^0",
     "content":"PARITY⊂ACC^0",
     "desc":"PARITY is decided by a single mod-2 gate in ACC^0, so it's contained. This is strict because ACC^0 contains the language 'is the first bit zero' and PARITY does not.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"PARITY⊂REG",
     "content":"PARITY⊂REG",
     "desc":"PARITY is decided by the regex (11)*. It can't recognize any other regex, so there is a strict inclusion.",
     "impliedby":"ObviousConstruction"
    }, 
    {"name":"SF⊆REG",
     "content":"SF⊆REG",
     "impliedby":"ObviousConstruction"
    },
    {"name":"REG⊆CFL",
     "content":"REG⊆CFL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"CFL⊆LOGCFL",
     "content":"CFL⊆LOGCFL",
     "impliedby":"ObviousConstruction"
    },
      
    {"name":"L⊆RL",
     "content":"L⊆RL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"RL⊆NL",
     "content":"RL⊆NL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"P⊆ZPP",
     "content":"P⊆ZPP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"ZPP=RP∩coRP",
     "content":"ZPP⊆RP&&ZPP⊆coRP",
     "impliedby":"ObviousConstruction",
     "notes":"the 'content' only has one way implication right now. TODO describing cocap more cleanly"
    },
    {"name":"RP⊆BPP",
     "content":"RP⊆BPP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"coRP⊆BPP",
     "content":"coRP⊆BPP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"RP⊆NP",
     "content":"RP⊆NP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"coRP⊆coNP",
     "content":"coRP⊆coNP",
     "impliedby":"ObviousConstruction"
    },
    
    {"name":"RNC⊆RP",
     "content":"RNC⊆RP",
     "impliedby":"ObviousConstruction"
    }, 
    
    {"name":"QNC⊆BQP",
     "content":"QNC⊆BQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"NP⊆NQP",
     "content":"NP⊆NQP",
     "ref":"NQP can simulate any NP machine by only using classical circuits, and Hadamard gates to prepare random coins.",
     "impliedby":"ObviousConstruction"
    },
      
    {"name":"P⊆GAK",
     "content":"P⊆GAK",
     "impliedby":"ObviousConstruction"
    },
    {"name":"P⊆GIK",
     "content":"P⊆GIK",
     "impliedby":"ObviousConstruction"
    },
    {"name":"GAK⊆GA",
     "content":"GAK⊆GA",
     "impliedby":"ObviousConstruction"
    },
    {"name":"GIK⊆GI",
     "content":"GIK⊆GI",
     "impliedby":"ObviousConstruction"
    },
    {"name":"GIK⊆NP",
     "content":"GIK⊆NP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"GI⊆Δ2",
     "content":"GI⊆Δ2",
     "ref":"GI is P with a GraphIsomorphism oracle, while Δ2 is P with an NP oracle, which is at least as strong since GraphIsomorphism is in NP.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"SZK⊆AM",
     "content":"SZK⊆AM",
     "ref":"AM is just SZK where you relax the condition on not leaking knowledge",
     "impliedby":"ObviousConstruction"
    },
    {"name":"SBP⊆A_0PP",
     "content":"SBP⊆A_0PP",
     "ref":"SBP is defined in terms of #P, and A_0PP is defined in terms of GapP. Since GapP obviously includes all of #P, A_0PP obviously includes all of SBP. Alternately, see {thm:SBP⊆SBQP} as another obvious reason, and we know {thm:SBQP=A_0PP} -- TODO.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"NP⊆MA",
     "content":"NP⊆MA",
     "impliedby":"ObviousConstruction"
    },
    {"name":"coNP⊆coMA",
     "content":"coNP⊆coMA",
     "impliedby":"ObviousConstruction"
    },
    {"name":"MA⊆AM",
     "content":"MA⊆AM",
     "impliedby":"ObviousConstruction"
    },
    {"name":"coMA⊆coAM",
     "content":"coMA⊆coAM",
     "impliedby":"ObviousConstruction"
    },
    {"name":"PH⊆AP",
     "content":"PH⊆AP",
     "ref":"PH is polynomial time with some bounded integer k alternations, while AP is unbounded alternations.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"P⊆EQP",
     "content":"P⊆EQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"EQP⊆BQP",
     "content":"EQP⊆BQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"BPP⊆BQP",
     "content":"BPP⊆BQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"DQC1⊆BQP",
     "content":"DQC1⊆BQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"BQP⊆DQP",
     "content":"BQP⊆DQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"BPP⊆NISQ",
     "content":"BPP⊆NISQ",
     "impliedby":"ObviousConstruction"
    },
    {"name":"NISQ⊆BQP",
     "content":"NISQ⊆BQP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"BQP⊆QCMA",
     "content":"BQP⊆QCMA",
     "impliedby":"ObviousConstruction"
    },
    {"name":"MA⊆QCMA",
     "content":"MA⊆QCMA",
     "impliedby":"ObviousConstruction"
    },
    {"name":"QCMA⊆QMA",
     "content":"QCMA⊆QMA",
     "impliedby":"ObviousConstruction"
    },
    {"name":"PP⊆CH",
     "content":"PP⊆CH",
     "ref":"The CH hierarchy is built by taking P and repeatedly giving PP oracles, so PP is the first level.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"CH⊆PSPACE",
     "content":"CH⊆PSPACE",
     "impliedby":"ObviousConstruction"
    },
    {"name":"IP⊆QIP",
     "content":"IP⊆QIP",
      "impliedby":"ObviousConstruction"
    },
    {"name":"P⊆E",
     "content":"P⊆E",
     "impliedby":"ObviousConstruction"
    },
    {"name":"E⊆EXP",
     "content":"E⊆EXP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"PSPACE⊆EXP",
     "content":"PSPACE⊆EXP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"EXP⊆NEXP",
     "content":"EXP⊆NEXP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"EXP⊆ELEMENTARY",
     "content":"EXP⊆ELEMENTARY",
     "impliedby":"ObviousConstruction"
    },
    {"name":"NEXP⊆ELEMENTARY",
     "content":"NEXP⊆ELEMENTARY",
     "impliedby":"ObviousConstruction"
    },
    {"name":"ELEMENTARY⊆TOWER",
     "content":"ELEMENTARY⊆TOWER",
     "impliedby":"ObviousConstruction"
    },
    {"name":"TOWER⊆PR",
     "content":"TOWER⊆PR",
     "impliedby":"ObviousConstruction"
    },
    {"name":"PR⊆ACKERMANN",
     "content":"PR⊆ACKERMANN",
     "impliedby":"ObviousConstruction"
    },
    {"name":"ACKERMANN⊆R",
     "content":"ACKERMANN⊆R",
     "impliedby":"ObviousConstruction"
    },
    {"name":"R⊆RE",
     "content":"R⊆RE",
     "impliedby":"ObviousConstruction"
    },
    {"name":"R⊆coRE",
     "content":"R⊆coRE",
     "impliedby":"ObviousConstruction"
    },
    {"name":"coRE⊆ALL",
     "content":"coRE⊆ALL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"RE⊆ALL",
     "content":"RE⊆ALL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"ObviousConstruction",
     "content":"",
     "ref":"Placeholder theorem for 'obvious' statements, like DTIME(f)⊆NDTIME(f), as a source for other statements. Ideally uses of this would be minimized and replaced by more precise statements that could be verified."
    },
      
    //Parameterized world
    {"name":"Kernel⊆FPT",
     "content":"Kernel⊆FPT",
     "desc":"Kernelization is a common way to give an FPT algorithm",
     "impliedby":"ObviousConstruction"
    },
    {"name":"para-L⊆para-NL",
     "content":"para-L⊆para-NL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"para-NL⊆FPT",
     "content":"para-NL⊆FPT",
     "impliedby":"ObviousConstruction"
    },
    {"name":"FPT⊆W[1]",
     "content":"FPT⊆W[1]",
     "ref":"The W hierarchy is defined under FPT reductions, so the class FPT is equivalent to the trivial language in the W hierarchy -- placing it at the lowest level",
     "impliedby":"ObviousConstruction"
    },
    {"name":"W[1]⊆W[2]",
     "content":"W[1]⊆W[2]",
     "impliedby":"ObviousConstruction"
    },
    {"name":"W[2]⊆W[P]",
     "content":"W[2]⊆W[P]",
     "impliedby":"ObviousConstruction"
    },
    {"name":"W[P]⊆para-NP",
     "content":"W[P]⊆para-NP",
     "ref":"The W hierarchy is in terms of circuits with poly(n) inputs satisfiable by setting f(k) inputs to 1. The set of bits to set is the witness of the para-NP checker.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"W[P]⊆XP",
     "content":"W[P]⊆XP",
     "ref":"The W hierarchy is in terms of circuits with poly(n) inputs satisfiable by setting f(k) inputs to 1. Trying all n-choose-k inputs gives an O(n^k) algorithm to solve them, therefore all W[i] are in XP.",
     "impliedby":"ObviousConstruction"
    },
    {"name":"XL⊆XNL",
     "content":"XL⊆XNL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"XNL⊆XP",
     "content":"XNL⊆XP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"XP⊆XNP",
     "content":"XP⊆XNP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"para-L⊆XL",
     "content":"para-L⊆XL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"para-NL⊆XNL",
     "content":"para-NL⊆XNL",
     "impliedby":"ObviousConstruction"
    },
    {"name":"FPT⊆XP",
     "content":"FPT⊆XP",
     "impliedby":"ObviousConstruction"
    },
    {"name":"para-NP⊆XNP",
     "content":"para-NP⊆XNP",
     "impliedby":"ObviousConstruction"
    }
  ],
    
  "references":[
    {"name":"Aar05",
     "desc":"Quantum computing and hidden variables, Physical Review A 71:032325, March 2005.",
     "url":["https://doi.org/10.1103/PhysRevA.71.032325","https://arxiv.org/abs/quant-ph/0408035"]
    },
    {"name":"AG95",
     "desc":"Allender, Eric; Gore, Vivec (1994), A uniform circuit lower bound for the permanent (PDF), SIAM Journal on Computing, 23 (5): 1026–1049, doi:10.1137/S0097539792233907",
     "url":["https://doi.org/10.1137/S0097539792233907"]
    },
    {"name":"BFL91",
     "desc":"L. Babai, L. Fortnow, and C. Lund. Nondeterministic exponential time has two-prover interactive protocols, Computational Complexity 1:3-40, 1991. doi:10.1109/FSCS.1990.89520",
     "url":["https://doi.org/10.1109/FSCS.1990.89520","http://people.cs.uchicago.edu/~fortnow/papers/mip2.ps"]
    },
    {"name":"BGM02",
     "desc":"E. Böhler, C. Glaßer, and D. Meister. Error-bounded probabilistic computations between MA and AM, Mathematical foundations of computer science 2003, 249--258.",
     "url":["http://haegar.informatik.uni-wuerzburg.de/users/glasser/publications/sbp-ma-am-tr.pdf"]
    },
    {"name":"BM88",
     "desc":"L. Babai and S. Moran. Arthur-Merlin games: a randomized proof system, and a hierarchy of complexity classes, Journal of Computer and Systems Sciences 36:254-276, 1988.",
     "url":["https://doi.org/10.1016/0022-0000(88)90028-1"]
    },
    {"name":"Bor77",
     "desc":"A. Borodin. On relating time and space to size and depth, SIAM Journal on Computing 6:733-744, 1977."
    },
    {"name":"CKS81",
     "desc":"A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer. Alternation, Journal of the ACM 28:114-133, 1981."
    },
    {"name":"Joh90",
     "desc":"D. S. Johnson. A catalog of complexity classes, chapter 2 in Handbook of Theoretical Computer Science, Volume A (J. van Leeuwen, editor), Elsevier, 1990."
    },
    {"name":"JNVWY20",
     "desc":"Z. Ji, A. Natarajan, T. Vidick, J. Wright, H. Yuen. MIP* = RE, arXiv:2001.04383, 2020.",
     "url":["https://arxiv.org/abs/2001.04383"]
    },
    {"name":"JJUW09",
     "desc":"R. Jain, Z. Ji, S. Upadhyay, and J. Watrous. QIP = PSPACE, J. ACM 58(6):1-27, 2011. doi:10.1145/2049697.2049704 arXiv:0907.4737.",
     "url":["https://dl.acm.org/doi/10.1145/1806689.1806768","https://dl.acm.org/doi/10.1145/2049697.2049704","http://arxiv.org/abs/0907.4737"]
    },
    {"name":"KL98",
     "desc":"Knill, Emanuel; Laflamme, Raymond (1998). Power of One Bit of Quantum Information. Physical Review Letters. 81 (25): 5672–5675. arXiv:quant-ph/9802037. Bibcode:1998PhRvL..81.5672K. doi:10.1103/PhysRevLett.81.5672. S2CID 118931256.",
     "url":["https://doi.org/10.1103/PhysRevLett.81.5672"]
    },
    {"name":"Lin23",
     "desc":"Junqiao Lin. Almost synchronous correlations in the commuting operator model, arXiv:2304.01940. 2023",
     "url":["https://arxiv.org/abs/2304.01940"]
    },
    {"name":"FR98",
     "desc":"L. Fortnow and J. D. Rogers. Complexity limitations on quantum computation, Proceedings of IEEE Complexity'98, pp. 202-209, 1998. arXiv:cs.CC/9811023.",
     "url":["https://arxiv.org/abs/cs/9811023"]
    },
    {"name":"GS86",
     "desc":"S. Goldwasser and M. Sipser. Private coins versus public coins in interactive proof systems, Proceedings of ACM STOC'86, pp. 58-68, 1986. doi:10.1145/12130.12137",
     "url":["https://doi.org/10.1145/12130.12137"]
    },
    {"name":"MW18",
     "desc":"Murray, Cody D.; Williams, Ryan (2018), Circuit Lower Bounds for Nondeterministic Quasi-Polytime: An Easy Witness Lemma for NP and NQP, Proc. 50th ACM Symposium on Theory of Computing, pp. 890–901, doi:10.1145/3188745.3188910, hdl:1721.1/130542, S2CID 3685013",
     "url":["https://doi.org/10.1145/3188745.3188910","https://people.csail.mit.edu/rrw/easy-witness-nqp.pdf"]
    },
    {"name":"NPA08",
     "desc":"Miguel Navascués, Stefano Pironio, and Antonio Acín. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics, 10(7):073013, 2008.",
     "url":["https://doi.org/10.1088/1367-2630/10/7/073013","https://arxiv.org/abs/0803.4290"]
    },
    {"name":"Raz87",
     "desc":"Razborov, A. A. (1987), Lower bounds for the size of circuits of bounded depth with basis {⊕,∨}, Math. Notes of the Academy of Science of the USSR, 41 (4): 333–338."
    },
    {"name":"Sha90",
     "desc":"A. Shamir. IP=PSPACE, Proceedings of IEEE FOCS'90, pp. 11-15, 1990.",
     "url":["https://doi.org/10.1109/FSCS.1990.89519"]
    },
    {"name":"Smo87",
     "desc":"Smolensky, R. (1987), Algebraic methods in the theory of lower bounds for Boolean circuit complexity, Proc. 19th ACM Symposium on Theory of Computing, pp. 77–82, doi:10.1145/28395.28404.",
     "url":["https://doi.org/10.1145/28395.28404"]
    },
    {"name":"Ven91",
     "desc":"H. Venkateswaran. Properties that characterize LOGCFL, Journal of Computer and System Sciences 43(2):380-404, 1991. doi:10.1016/0022-0000(91)90020-6 Originally appeared in STOC 1987",
     "url":["https://doi.org/10.1016/0022-0000(91)90020-6"]
    },
    {"name":"Vya03",
     "desc":"M. Vyalyi. QMA=PP implies that PP contains PH, ECCC TR03-021, 2003.",
     "url":["https://eccc.weizmann.ac.il/report/2003/021/"]
    },
    {"name":"Wil11",
     "desc":"Williams, Ryan (2011). Non-uniform ACC Circuit Lower Bounds. 2011 IEEE 26th Annual Conference on Computational Complexity (PDF). pp. 115–125. doi:10.1109/CCC.2011.36. ISBN 978-1-4577-0179-5."
    }
   ]
}
    
