[{"name":"para-L","equals":[],"properties":[],"notes":"","desc":"Parameterized Logspace. Languages (x,k) with a deterministic algorithm running in space f(k)+O(log(n)).","related":["para-NL","XL"],"children":["XL","para-NL"]},{"name":"para-NL","equals":[],"properties":[],"notes":"","desc":"Parameterized Nondeterministic Logspace. Languages (x,k) with a nondeterministic algorithm running in space f(k)+O(log(n)).","related":["para-L","XNL"],"children":["XNL","FPT"]},{"name":"FPT","equals":[],"properties":[],"notes":"","desc":"Fixed Parameter Tractable. Languages (x,k) with a deterministic algorithm running in time n^{O(1)}*f(k).","related":["XP","W[1]"],"children":["W[1]"]},{"name":"W[1]","equals":[],"properties":[],"notes":"todo def","desc":"Weft-1 circuits.","related":["W[P]","W[2]","FPT","XP"],"children":["W[2]"]},{"name":"W[2]","equals":[],"properties":[],"notes":"todo def","desc":"Weft-2 circuits.","related":["W[P]","FPT","XP","W[1]"],"children":["W[P]"]},{"name":"W[P]","equals":[],"properties":[],"notes":"todo def","desc":"Polynomial Weft circuits. Equivalently, problems with a witness that can be verified by a polynomial-time machine (an unparameterized polynomial time, n^{O(1)}, in the size of the input and witness), with a witness of size f(k)*O(log(n)). Compare with para-NP, XP, which are also a version of parameterized nondeterminism.","related":["para-NP","FPT","XP","W[1]"],"children":["para-NP","XP"]},{"name":"para-NP","equals":[],"properties":[],"notes":"","desc":"Parameterized NP. Languages (x,k) with a nondeterministic algorithm running in time f(k)*n^{O(1)}. Equivalently, problems with a deterministic polynomial-time verifier that take a problem and witness, and the witness is of size f(k)*n^{O(1)}. A classic example is k-coloring: it's in NP for any k, and fixing k at a low value (such as 3) leaves it difficult. Since k-coloring is atually para-NP-hard too, it's para-NP-complete. Compare with XNP, where the exponent of the machine is allowed to depend on k.","related":["NP","XNP","XP"],"children":["XNP"]},{"name":"XL","equals":[],"properties":[],"notes":"","desc":"Slicewise Logspace. Languages (x,k) with a deterministic algorithm running in space f(k)*log(n).","related":["FPT","W[1]"],"children":["XNL"]},{"name":"XNL","equals":[],"properties":[],"notes":"","desc":"Slicewise Nondeterministic Logspace. Languages (x,k) with a nondeterministic algorithm running in space f(k)*log(n).","related":["XL","XP"],"children":["XP"]},{"name":"XP","equals":[],"properties":[],"notes":"","desc":"Slicewise Polynomial time. Languages (x,k) with a deterministic algorithm running in time n^f(k).","related":["FPT","W[1]"],"children":["XNP"]},{"name":"XNP","equals":[],"properties":[],"notes":"","desc":"Slicewise NP. Languages (x,k) with a nondeterministic algorithm running in time n^f(k). Equivalently, problems with witnesses of size n^{f(k)} with a polynomial-time verifier.","related":["para-NP","XP"],"children":[]},{"name":"Kernel","equals":[],"properties":[],"notes":"","desc":"Problems that admit kernelization: languages (x,k) for which there is a _kernelization algorithm_ that processes the original instance in time poly(n,k) = (n+k)^{O(1)}, and produces an output string K of size f(k) for a computable function f, so that the original instance can be decided by running some (computable) algorithm on K. See [Wikipedia](https://en.wikipedia.org/wiki/Kernelization#Downey%E2%80%93Fellows_notation) for more details. This is a stronger requirement than being FPT, by essentially saying that the \"slow\" part of the algorithm that depends on k shouldn't need the whole input.","related":["FPT"],"children":["FPT"]}]