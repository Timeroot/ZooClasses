[{"name":"A_0PP","equals":[],"properties":[],"notes":"","desc":"TODO. Defined in {ref:Vya03}.","related":["SBP","PP","AWPP"],"children":["PP"]},{"name":"AC","equals":false,"properties":["circuit"],"notes":"","desc":"Unbounded Fanin Polylogarithmic-Depth Circuits. The class of decision problems solvable by a nonuniform family of Boolean circuits, with polynomial size, depth O(log^k(n)), and unbounded fanin, for some k. The gates allowed are AND, OR, and NOT. For a given k, we get AC^k, such as AC^1. The class AC^0 is when k=0 i.e. constant depth. Equal to NC and TC.","related":["NC","AC^0","AC^1","TC"],"children":[]},{"name":"AC^0","equals":[],"properties":["circuit"],"notes":"","desc":"Unbounded Fanin Constant-Depth Circuits. An especially important subclass of AC, corresponding to constant-depth, unbounded-fanin, polynomial-size circuits with AND, OR, and NOT gates.","related":["NC","NC^0","AC^1","AC^0"],"children":["ACC^0"]},{"name":"AC^1","equals":[],"properties":["circuit"],"notes":"","desc":"Unboudned Fanin Log-depth Circuits.","related":["AC","TC^1","NC^1","AC^0"],"children":["TC^1"]},{"name":"ACC^0","equals":[],"properties":["circuit"],"notes":"","desc":"AC0 With Arbitrary MOD Gates. Polynomial size, constant depth.","related":["AC^0","TC^0"],"children":["nuACC^0","TC^0"]},{"name":"ACKERMANN","equals":[],"properties":[],"notes":"","desc":"Ackermann function time. Problems solvable by a Turing machine in time A(O(n),O(n)), where A is the Ackermann function. Reachability in vector addition systems is complete for this class, placing it strictly above PR.","related":["PR"],"children":["R"]},{"name":"ALL","equals":[],"properties":[],"notes":"","desc":"All languages. Everything is contained in this class. Not considered feasible.","related":["RE","R"],"children":[]},{"name":"AM","equals":[],"properties":[],"notes":"todo def","desc":"Arthur-Merlin games. In general, AM[k] is k-round interactive protocols between am omniscient Merlin and a polytime Arthur. Arthur has randomness, but Merlin can see all of Arthur's randomness, and they exchange polynomial size messages, and Arthur becomes convinced with 2/3 soundness and completeness. It turns out that AM[k]=AM[2] for any constant k, TODO reference, and then the class AM is defined as AM[2]. This doesn't translate to polynomial k, as the message sizes grows by at least a constant factor with each removed round, leading to exponential slowdown if you tried to run AM[poly] as a AM[2] protocol. As other cases, there are AM[0]=BPP, AM[1]=MA, and AM[poly(n)]=IP. There is also the odd one AM[polylog(n)].\n Compare with IP[k], which has private coins: Merlin can't see Arthur's random choices.","related":["NP","IP","MA"],"children":["Π2"]},{"name":"AP","equals":false,"properties":[],"notes":"todo def","desc":"Alternating polynomial time. Polynomial time with unlimited switches between an \"NP\"-like \"OR\" mode, and a coNP \"AND\" mode.","related":["PSPACE","PH"],"children":[]},{"name":"AWPP","equals":[],"properties":[],"notes":"","desc":"TODO","related":["A_0PP","SBP"],"children":["A_0PP"]},{"name":"BPL","equals":[],"properties":[],"notes":"","desc":"Bounded error Probabilistic Logspace. Problems with a probabilistic logarithmic space Turing machine with at least a 2/3 chance of a correct answer and a termination probability of 1","related":["PromiseBPP","RL","L","ZPL","NL"],"children":["DET"]},{"name":"BPP","equals":["FH^1"],"properties":[],"notes":"","desc":"Bounded error Probabilistic Polynomial time. Problems with a probabilistic polynomial-time Turing machine with at least a 2/3 chance of a correct answer.","related":["RP","PromiseBPP","ZPP"],"children":["NISQ","Π2","Σ2","FH^2"]},{"name":"BQP","equals":[],"properties":["quantum"],"notes":"","desc":"TODO","related":["EQP","NISQ","IQP","BPP","QMA"],"children":["QCMA","QSZK","DQP","AWPP"]},{"name":"C_{eq}L","equals":[],"properties":[],"notes":"","desc":"Exact-Counting Logspace. Usually written C_=L, but we don't use that because of the difficulties having an = in the name causes. The class of decision problems solvable by an NL machine such that the number of accepting paths exactly equals the number of rejecting paths, if and only if the answer is 'yes.'. Logspace analog of {lang:C_{eq}P}.\nTODO: C_{eq}L^{C_{eq}L} = L^{C_{eq}L}, by {ref:ABO99}.","related":["C_{eq}P","L","NL"],"children":["coNQP"]},{"name":"C_{eq}P","equals":false,"properties":[],"notes":"","desc":"Exact-Counting Polynomial-Time. Usually written C_{eq}P, but we don't use that because of the difficulties having an = in the name causes. The class of decision problems solvable by an NP machine such that the number of accepting paths exactly equals the number of rejecting paths, if and only if the answer is 'yes.'.\n{thm:C_{eq}P=coNQP}, by {ref:FGH+98}. ","related":["C_{eq}L","coNQP","NQP"],"children":[]},{"name":"CFL","equals":[],"properties":[],"notes":"","desc":"Context-Free languages","related":["CSL","REG"],"children":["NLINSPACE","SAC^1"]},{"name":"CH","equals":[],"properties":[],"notes":"","desc":"Counting Hierarchy. Union of PP, PP^PP, PP^(PP^PP), and so on. With the counting operator C[M] = PP^M, we can say that CH = C^O(1)[P], analogous to how PH = Σ^O(1)[P] = Π^O(1)[P]","related":["PP"],"children":["PSPACE"]},{"name":"CSL","equals":false,"properties":[],"notes":"","desc":"Context-Sensitive languages. Precisely the languages that can be described by a https://en.wikipedia.org/wiki/Context-sensitive_grammar. Equal to {lang:NLINSPACE}, see {thm:CSL=NLINSPACE}.","related":["CFL","REG"],"children":[]},{"name":"coAM","equals":[],"properties":["complement"],"notes":"todo def","desc":"Complement of Arthur-Merlin games, {lang:AM}.","related":["coMA","AM"],"children":["Σ2"]},{"name":"coNL","equals":false,"properties":["complement"],"notes":"","desc":"Complement of Nondeterministic Logarithmic space, {lang:NL}. Problems decided in logarithmic space by a deterministic Turing machine. Actually equal to {lang:NL}, a consequence of {thm:Immerman–Szelepcsényi theorem}.","related":[],"children":[]},{"name":"coMA","equals":[],"properties":["complement"],"notes":"todo def. todo coMA=coMA1","desc":"Complement of Merlin-Arthur games, {lang:MA}.","related":["coAM","MA"],"children":["coAM"]},{"name":"coNP","equals":[],"properties":["complement"],"notes":"todo: verifier definition","desc":"Complement of Nondeterministic Polynomial time, {lang:coNP}. Problems whose complement decided in polynomial time by a nondeterministic Turing machine; or equivalently, problems that can be disproved by a polynomial-time checkable witness.","related":[],"children":["Δ2","coNQP","coMA"]},{"name":"coNQP","equals":["C_{eq}P"],"properties":["complement"],"notes":"","desc":"Complement of Nondeterministic Quantum Polynomial time. Complement of {lang:NQP}.","related":["NQP"],"children":["PSPACE"]},{"name":"coRE","equals":[],"properties":["complement"],"notes":"todo: definition as a Turing machine","desc":"Complement of Recursively enumerable languages, {lang:RE}. Languages whose rejection can be recognized by a Turing machine.","related":["RE"],"children":["ALL"]},{"name":"coRBQP","equals":[],"properties":["complement"],"notes":"","desc":"Complement of {lang:RBQP}.","related":["RBQP"],"children":["coNP","coRQP"]},{"name":"coRL","equals":[],"properties":["complement"],"notes":"todo: complement of RL","desc":"Complement of Randomized Logspace, {lang:RL}.","related":["RL"],"children":["NL","BPL"]},{"name":"coRP","equals":[],"properties":["complement"],"notes":"todo: complement of RP","desc":"Complement of Randomized Polynomial time, {lang:RP}. Problems with a probabilistic polynomial-time Turing machine with zero error on YES instances","related":["RP"],"children":["coRBQP","BPP"]},{"name":"coRQP","equals":[],"properties":["complement"],"notes":"","desc":"Complement of {lang:RQP}.","related":["RQP"],"children":["BQP"]},{"name":"CZK","equals":[],"properties":[],"notes":"","desc":"Computational Zero Knowledge. The class of problems possessing computational zero-knowledge proof systems.","related":["SZK"],"children":[]},{"name":"DET","equals":[],"properties":[],"notes":"","desc":"Problems F{lang:L}-reducible to computing the determinant of an n-by-n matrix of n-bit integers. ComplexityZoo says the corresponding function class is GapL (TODO ref). Sometimes denoted by L^{DET}.","related":["NC^2","NL"],"children":["NC^2"]},{"name":"DQC1","equals":[],"properties":[],"notes":"","desc":"Deterministic Quantum Computing with 1 Clean Bit. The class of problems solvable by a BQP machine in which a single qubit is initialized to the '0' state, and the remaining qubits are initialized to the maximally mixed state. Defined in {ref:KL98}. This has been called BQ1P, sometimes, to distinguish it from the _sampling_ problem of DQC1 circuits. Since \"DQC1\" seems to have stuck, we call the sampling problem DQC1S.","related":["DQC1S","BQP"],"children":["BQP"]},{"name":"DQP","equals":[],"properties":[],"notes":"","desc":"Dynamical Quantum Polynomial-Time.The class of decision problems solvable by a BQP machine with oracle access to a dynamical simulator. When given a polynomial-size quantum circuit, the simulator returns a sample from the distribution over \"classical histories\" induced by the circuit. The simulator can adversarially choose any history distribution that satisfies the axioms of \"symmetry\" and \"locality\" -- so that the DQP algorithm has to work for any distribution satisfying these axioms. Defined in {ref:Aar05}.","related":["BQP"],"children":["EXP"]},{"name":"E","equals":[],"properties":[],"notes":"","desc":"(Linear) Exponential time. Problems decided in exponential time with linear exponent, by a deterministic Turing machine.","related":[],"children":["EXP"]},{"name":"ELEMENTARY","equals":[],"properties":[],"notes":"","desc":"Elementary languages. The union of EXP, EEXP, EEXP, etc.: solvable by a Turing machine with runtime 2^n, 2^(2^n), 2^(2^(2^n)) for some height. Equivalently, DTIME(^{O(1)}n), where ^{a}b indicates the tetration of b to the height a.","related":["EXP"],"children":["TOWER"]},{"name":"EQP","equals":[],"properties":[],"notes":"","desc":"TODO","related":["RQP","ZQP","BQP"],"children":["ZQP"]},{"name":"EXP","equals":[],"properties":[],"notes":"","desc":"Exponential time. Problems decided in singly exponential time by a deterministic Turing machine.","related":[],"children":["NEXP"]},{"name":"FH","equals":[],"properties":[],"notes":"","desc":"FH^k is the class of problems solvable by a uniform family of polynomial-size quantum circuits, with k levels of Hadamard gates and all other gates preserving the computational basis. (Conditional phase flip gates are fine, for example.) FH is the union of FH^k across all k, in other words, problems solvable by a uniform family with O(1) Hadamard layers. FH^0 is definitionally equal to {lang:P}, and {lang:FH^1}={lang:BPP} -- see {thm:FH^1=BPP}. The first \"quantum\" class is {lang:FH^2}, which includes factoring.\nIt is an open problem to show that the Fourier hierarchy is infinite relative to an oracle (that is, FHk is strictly contained in FHk+1).\nDefined in {ref:Shi03}.","related":["FH^1","FH^2","BQP"],"children":["BQP"]},{"name":"FH^1","equals":false,"properties":[],"notes":"","desc":"See {lang:FH} for definition. It is equal to {lang:BPP} by {thm:FH^1=BPP}.","related":["FH^2","BPP","FH"],"children":[]},{"name":"FH^2","equals":[],"properties":[],"notes":"","desc":"See {lang:FH} for definition. It contains factoring.","related":["FH^1","BQP"],"children":["FH"]},{"name":"GA","equals":[],"properties":[],"notes":"","desc":"Graph Automorphism. Languages that can be polynomial-time Turing reduced to Graph Automorphism. Compare with GI for isomorphism, and GAK for Karp reductions.","related":["GI","GAK"],"children":["GI"]},{"name":"GAK","equals":[],"properties":[],"notes":"","desc":"Graph Automorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.","related":["GIK","GA"],"children":["GA"]},{"name":"GI","equals":[],"properties":[],"notes":"","desc":"Graph Isomorphism. Languages that can be polynomial-time Turing reduced to Graph Isomorphism. This is, in some sense, a powerful reduction; compare with GIK for Karp reductions. Compare with GA which only allows automorphism checking.","related":["GIK","GA"],"children":["Δ2"]},{"name":"GIK","equals":[],"properties":[],"notes":"","desc":"Graph Isomorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.","related":["GI","GAK"],"children":["NP","SZK","GI"]},{"name":"IP","equals":false,"properties":[],"notes":"","desc":"Interactive Proofs. In general, IP[r] means a proof where a player exchanges r rounds with a polynomial time verifier; the verifier has private random coins. The class IP is defined as IP[poly(n)], and it turns out that IP=PSPACE, see {ref:Sha90}. For IP[r] with a constant r, it turns to be equal to AM; see AM for more. {ref:BM88} also proved that IP[f(n)]=IP[c*f(n)].","related":["MIP","QIP","PSPACE","AM"],"children":[]},{"name":"L","equals":[],"properties":[],"notes":"todo SL","desc":"Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.","related":["L^2","NL"],"children":["DQC1","C_{eq}L","ZPL"]},{"name":"L^2","equals":[],"properties":[],"notes":"","desc":"Logarithmic-squared space. Problems decided in O(log(n)^2) -- _not_ to be confused with O(log^2(n)) -- space by a deterministic Turing machine.","related":["L","NL"],"children":["LINSPACE"]},{"name":"LINSPACE","equals":[],"properties":[],"notes":"","desc":"Deterministic Linear space. Problems decided in linear space by a deterministic Turing machine.","related":["NLINSPACE","PSPACE"],"children":["PSPACE"]},{"name":"LOGCFL","equals":false,"properties":["circuit"],"notes":"","desc":"The class of decision problems reducible in L to the problem of deciding membership in a context-free language. In order words, the closure under L-reductions of {lang:CFL}. Equivalently, LOGCFL is the class of decision problems solvable by a _uniform_ family of AC1 circuits, in which no AND gate has fan-in exceeding 2, see {ref:Joh90}{ref:Ven91}. When the circuits aren't uniform, we get the LOGCFL/poly = SAC^1, see {lang:SAC^1}.","related":["CFL","SAC^1"],"children":[]},{"name":"MA","equals":[],"properties":[],"notes":"todo def. todo MA=MA1","desc":"Merlin-Arthur games","related":["NP","AM","QMA"],"children":["QCMA","StoqMA","SBP"]},{"name":"MIP","equals":false,"properties":[],"notes":"","desc":"Multiple-player Interactive Proofs. In general, MIP[p,r] means a proof with p player who cannot communicate, and r rounds of interaction with a referee. (The final round is always a message to the referee, as a final message to a player cannot be useful.) As it turns out, MIP[p,r]=MIP[2,1] for any p>=2 and r>=1, so the distinction is largely unnecessary. MIP[1,r] is better known as AM[r], see AM for more. \n And of course MIP[p,0] is just P. :)\n\nMIP[p,r]=MIP[2,poly] is proved in {ref:BFL91}. I can't find a source for the statement that MIP[2,poly]=MIP[2,1].","related":["IP","QIP","NEXP","AM","MIP*","MIPco"],"children":[]},{"name":"MIP*","equals":false,"properties":[],"notes":"","desc":"Multiple-player Interactive Proofs, with entanglement. Traditionally defined with polynomially many players and rounds, but it turns out that MIP*[poly,poly]=MIP*[2,1], so one can just think of as two players and one round. \n When the provers are allowed to have (unbounded) entanglement, this allows them to cheat at some games, so it is not obvious that MIP* is as big as {lang:MIP}; it is only clear that one can ignore all but one player and get the class IP as a lower bound. But, having entanglement also means we can ask more from the players -- much more, and it turns out that {thm:MIP*=RE}, and includes undecidable problems.","related":["RE","MIP","MIPco"],"children":[]},{"name":"MIPco","equals":[],"properties":[],"notes":"","desc":"Multiple-player Interactive Proofs, with entanglement, in the _commuting_ operator framework. This was expected to be equal to {lang:MIP*}, but this isn't the case: {thm:MIP*=RE}, while MIPco is contained in {lang:coRE}. (It is expected that MIPco=coRE.) Nothing contained in coRE can equal RE!","related":["coRE","MIPco","MIP*"],"children":["coRE"]},{"name":"NC","equals":["AC","TC"],"properties":["circuit"],"notes":"","desc":"Nick's Class","related":["AC","NC^0","TC"],"children":["RNC","P"]},{"name":"NC^0","equals":["RNC^0"],"properties":["circuit"],"notes":"","desc":"Constant-Depth Nick's Class: uniform constant depth circuits with bounded-fanin gates. By definition, a decision problem in NC0 can depend on only a constant number of bits of the input. For that reason, \"NC^0\" is often used to refer to _functions_ computable by constant-depth, bounded-fanin circuits, instead of _decision_ problem. This comes up in NC^0 reduction. We opt to call that class of functions {lang:FNC^0} instead.","related":["NC","NC^1","FNC^0","AC^0","TC^0"],"children":["SAC^0","QNC^0"]},{"name":"NC^1","equals":[],"properties":["circuit"],"notes":"","desc":"Log-Depth Nick's Class","related":["TC^1","NC","NC^0","AC^1"],"children":["SAC^1","L","RNC^1"]},{"name":"NC^2","equals":[],"properties":["circuit"],"notes":"","desc":"Log^2-Depth Nick's Class","related":["DET","NC","AC^1"],"children":["NC"]},{"name":"NEXP","equals":["MIP"],"properties":[],"notes":"","desc":"Nondeterministic Exponential Time; also called NEXPTIME. Equivalently, problems with an EXP-size witness that can be verified by a polytime verifier (whose runtime is polynomial in the size of the input *and* the witness).","related":["EXP","NP"],"children":["MIPco","ELEMENTARY"]},{"name":"NISQ","equals":[],"properties":[],"notes":"","desc":"Problems solvable by a classical computer in poly(n) time with poly(n) queries to an λ-NQC oracle, which outputs samples from a λ-noisy quantum circuit: after each gate single gate, a λ-noise depolarizing channel is applied simultaneously to every qubit.","related":["IQP","BQP"],"children":["BQP"]},{"name":"NISZK","equals":[],"properties":[],"notes":"","desc":"Non-Interactive Statistical Zero Knowledge. A promise problem is in NISZK if there exists a polynomial-time probabilistic verifier V and a polynomial-time probabilistic simulator S such that: (1) For YES instances, there exists a polynomial-size message (the 'proof') that, when given to V, causes V to accept with high probability; (2) For NO instances, for any purported proof, V accepts with low probability; (3) For YES instances, the output distribution of V on the real proof is statistically indistinguishable from the output of S on the input alone (i.e., the verifier learns nothing beyond the validity of the statement). The protocol is non-interactive: the verifier receives a single message from the prover and then decides to accept or reject.","related":["SZK"],"children":["SZK"]},{"name":"NL","equals":["coNL"],"properties":[],"notes":"","desc":"Nondeterministic Logarithmic space. Problems decided in logarithmic space by a nondeterministic Turing machine.","related":[],"children":["NLINSPACE","DET","AC^1","L^2"]},{"name":"NLINSPACE","equals":["CSL"],"properties":[],"notes":"","desc":"Nondeterministic Linear space. Problems decided in linear space by a nondeterministic Turing machine. Equal to {lang:CSL}, the context-sensitive languages.","related":["LINSPACE","CSL","NPSPACE"],"children":["PSPACE"]},{"name":"NP","equals":[],"properties":[],"notes":"todo: verifier definition","desc":"Nondeterministic Polynomial time. Problems decided in polynomial time by a nondeterministic Turing machine.","related":[],"children":["NQP","Δ2","MA"]},{"name":"NPSPACE","equals":false,"properties":[],"notes":"","desc":"Nondeterministic polynomial space. Problems decided in polynomial space by a nondeterministic Turing machine. Actually equal to {lang:PSPACE}, as proved by {thm:Savitch's theorem}.","related":["NLINSPACE","PSPACE"],"children":[]},{"name":"NQP","equals":[],"properties":[],"notes":"","desc":"Nondeterministic Quantum Polynomial time. The class of decision problems solvable by a QTM in polynomial time such that a particular \"|Accept>\" state has nonzero amplitude at the end of the computation, if and only if the answer is \"yes.\"","related":["BQP","QMA"],"children":["A_0PP"]},{"name":"P","equals":[],"properties":[],"notes":"","desc":"Polynomial time. Problems decided in polynomial time by a deterministic Turing machine.","related":[],"children":["EQP","NISZK","GAK","PZK","E","ZPP","GIK"]},{"name":"PARITY","equals":[],"properties":[],"notes":"","desc":"The single language asking, 'Is the number of 1s in the input an even number'?","related":[],"children":["REG","ACC^0"]},{"name":"PH","equals":[],"properties":[],"notes":"todo","desc":"Polynomial hierarchy","related":["Δ2","PP"],"children":["PSPACE"]},{"name":"PP","equals":[],"properties":[],"notes":"todo def","desc":"Probabilistic Polynomial time.","related":["BPP"],"children":["CH"]},{"name":"PR","equals":[],"properties":[],"notes":"todo define PR *functions*","desc":"Primitive Recursive. Languages decidable in time bounded by a primitive recursive function of natural numbers.","related":["ELEMENTARY","ACKERMANN"],"children":["ACKERMANN"]},{"name":"PSPACE","equals":["AP","IP","NPSPACE","QIP"],"properties":[],"notes":"","desc":"Polynomial space. Problems decided in polynomial space by a deterministic Turing machine.","related":["AP","PH"],"children":["EXP"]},{"name":"PZK","equals":[],"properties":[],"notes":"todo def","desc":"Perfect Zero Knowledge. A promise problem is in PZK if there exists an interactive proof system (a polynomial-time probabilistic verifier interacting with a polynomial-time prover) such that: (1) For YES instances, there exists a polynomial-time prover that causes the verifier to accept with high probability; (2) For NO instances, for any prover, the verifier accepts with low probability; (3) For YES instances, there exists a polynomial-time simulator that, given only the input, can generate a transcript whose distribution is identically (not just statistically) distributed as the verifier's view in the real protocol. That is, the verifier learns nothing beyond the validity of the statement, and the simulation is perfect (the distributions are exactly equal, not just close).","related":["SZK"],"children":["SZK"]},{"name":"QAC^0","equals":[],"properties":["quantum"],"notes":"","desc":"Quantum AC^0. The class of decision problems solvable by constant-depth, polynomial-size uniform quantum circuit. Here each layer of the circuit is a tensor product of one-qubit gates and Toffoli gates, or is a tensor product of controlled-NOT gates. Quantum generalization of AC^0. It's unknown whether it contains AC^0.","related":["QAC","QNC^0","AC^0"],"children":["QAC"]},{"name":"QAC","equals":["QNC"],"properties":["quantum"],"notes":"","desc":"Quantum AC. The class of decision problems solvable by polylogarithmic-depth, polynomial-size uniform quantum circuit. Here each layer of the circuit is a tensor product of one-qubit gates and Toffoli gates, or is a tensor product of controlled-NOT gates. Quantum generalization of AC^0. Quantum generalization of AC.","related":["AC","QAC^0","QNC"],"children":["BQP"]},{"name":"QCMA","equals":[],"properties":["quantum"],"notes":"","desc":"Quantum-Classical Merlin-Arthur. Like {lang:QMA}, but Merlin's proof is a classical string; like NP, but the verifier has a quantum computer (a {lang:BQP} machine).","related":["QMA"],"children":["QMA"]},{"name":"QIP","equals":false,"properties":["quantum"],"notes":"","desc":"Quantum Interactive Proofs. Like {lang:IP}, but now messages can be quanutum. Only a single prover. For a different kind of 'quantum' interactive proof, there's the much harder {lang:MIP*} and {lang:MIPco}.","related":["IP","MIPco","MIP*"],"children":[]},{"name":"QMA","equals":[],"properties":["quantum"],"notes":"","desc":"Quantum Merlin-Arthur. Problems for which an omniscient 'Merlin' can submit a proof to 'Arthur' that a statement is true, and Arthur believes it with high probability (<1/3 chance of failing) -- but this proof can be a quantum state, and Arthur has a quantum computer.","related":["QCMA","BQP"],"children":["A_0PP"]},{"name":"QNC","equals":false,"properties":["quantum"],"notes":"","desc":"The class of decision problems solvable by polylogarithmic-depth quantum circuits with bounded probability of error. The zoo says, \"A uniformity condition may also be imposed.\"; for the purpose of this site we _do_ impose that condition. Some sources like https://dl.acm.org/doi/10.1145/3570637 refer to this as BQNC.","related":["RNC","NC","BQP"],"children":[]},{"name":"QNC^0","equals":[],"properties":["quantum"],"notes":"","desc":"Constant-depth quantum circuits","related":["QNC^0","QNC"],"children":["QNC^1","QAC^0"]},{"name":"QNC^1","equals":[],"properties":["quantum"],"notes":"","desc":"Log-depth quantum circuits","related":["QNC^0","QNC"],"children":["QAC"]},{"name":"QSZK","equals":[],"properties":[],"notes":"todo def","desc":"Quantum Statistical Zero Knowledge. A promise problem is in QSZK if there exists a quantum interactive proof system (a polynomial-time quantum verifier interacting with a polynomial-time quantum prover) such that: (1) For YES instances, there exists a polynomial-time quantum prover that causes the verifier to accept with high probability; (2) For NO instances, for any prover, the verifier accepts with low probability; (3) For YES instances, there exists a polynomial-time quantum simulator that, given only the input, can generate a quantum state (or transcript) whose distribution is statistically indistinguishable from the verifier's view in the real protocol. That is, the verifier learns nothing beyond the validity of the statement, even against quantum adversaries.","related":["SZK"],"children":["PSPACE"]},{"name":"R","equals":[],"properties":[],"notes":"todo: definition as a Turing machine, definition as intersection","desc":"Recursive languages. {lang:RE}∩{lang:coRE}. Languages solvable by a Turing machine.","related":["RE"],"children":["RE","coRE"]},{"name":"RBQP","equals":[],"properties":[],"notes":"todo: complement of coRBQP","desc":"Strict Quantum {lang:RP}\n(TODO: What does the B really stand for here?) The class of problems in {lang:NP} whose witnesses are in {lang:FBQP}. For example, the set of square-free numbers is in {lang:coRBQP} using only the fact that factoring is in {lang:FBQP}. (Even without a proof that the factors are prime, the factorization proves that there is a square divisor.).\nComplement is {lang:coRBQP}.","related":["RQP","ZQP","coRBQP"],"children":["RQP","NP"]},{"name":"RE","equals":["MIP*"],"properties":[],"notes":"todo: definition as a Turing machine","desc":"Recursively enumerable languages. Languages whose acceptance can be recognized by a Turing machine.","related":["R"],"children":["ALL"]},{"name":"REG","equals":[],"properties":[],"notes":"","desc":"Regular languages","related":["CFL"],"children":["CFL","NC^1"]},{"name":"RL","equals":[],"properties":[],"notes":"todo: complement of coRL","desc":"Randomized Logspace. Problems with a probabilistic logarithmic-space Turing machine with zero error on NO instances. Also, as a technicality, one requires a termination probability of 1 on all inputs.","related":["RP","L","NL"],"children":["BPL","NL"]},{"name":"RP","equals":[],"properties":[],"notes":"todo: complement of coRP","desc":"Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine with zero error on NO instances","related":["coRP","BPP","ZPP"],"children":["RBQP","BPP"]},{"name":"RQP","equals":[],"properties":[],"notes":"todo: complement of coRQP","desc":"One-sided Randomized Quantum Polynomial time.\nThe class of questions that can be answered by a QTM that accepts with probability 0 when the true answer is no, and accepts with probability at least 1/2 when the true answer is yes. (TODO: What are the precise requirements on runtime or termination?) Since one of the probabilities has to vanish, RQP has the same technical caveats as {lang:EQP}. Complement is {lang:coRQP}.","related":["EQP","ZQP","RBQP","coRQP"],"children":["BQP"]},{"name":"RNC","equals":[],"properties":["circuit"],"notes":"todo: complement of coRNC","desc":"Randomized Nick's Class. The class of decision problems solvable by polylogarithmic-depth random circuits with bounded one-sided probability of error: it must never incorrectly accept, and it must correctly reject at least 1/2 of the time.","related":["RP","NC","QNC"],"children":["QAC","RP"]},{"name":"RNC^0","equals":false,"properties":["circuit"],"notes":"","desc":"Randomized constant-depth circuits of bounded-fanin. Not very interesting because the randomness cannot be useful, so this is equal to NC^0. But the functional version FRNC^0 is slightly more interesting (in the same way that FNC^0 is more interesting than NC^0) and has been used in reductions, e.g. https://drops.dagstuhl.de/opus/volltexte/2023/17506/pdf/LIPIcs-ITCS-2023-3.pdf","related":["RNC","RNC^1"],"children":[]},{"name":"RNC^1","equals":[],"properties":["circuit"],"notes":"","desc":"Randomized log-depth circuits of bounded-fanin.","related":["RNC^0","RNC"],"children":["QNC^1","RNC"]},{"name":"SAC^0","equals":[],"properties":["circuit"],"notes":"","desc":"SAC^k is the class of decision problems solvable by a family of depth-O(logkn) circuits with unbounded-fanin OR & bounded-fanin AND gates. Negations are only allowed at the input level. A uniformity condition may also be imposed. SAC^k sits naturally 'halfway' between NC^k and AC^k.","related":["SAC^1","AC^0"],"children":["AC^0"]},{"name":"SAC^1","equals":["LOGCFL"],"properties":["circuit"],"notes":"","desc":"Semi-Unbounded-Fanin AC^1. See {ref:SAC^0} for definition. SAC^1 (with a uniformity condition) = LOGCFL, and without a uniformity condition = LOGCFL/poly, see {ref:Joh90}{ref:Ven91}.","related":["LOGCFL","AC^1","SAC^0"],"children":["AC^1"]},{"name":"SBP","equals":[],"properties":[],"notes":"TODO closed under union, ref BGM02.","desc":"Small Bounded-Error Probability. The class of decision problems for which the following holds. There exists a #P function f and an FP function g such that, for all inputs x,\n If the answer is \"yes\" then f(x) > g(x).\n If the answer is \"no\" then f(x) < g(x)/2.\n Defined in {ref:BGM02}.","related":["MA","AM","A_0PP","AWPP"],"children":["A_0PP","AM"]},{"name":"SF","equals":[],"properties":[],"notes":"","desc":"Star-free languages, see https://en.wikipedia.org/wiki/Star-free_language. A subset of regular languages, where constant terms are allowed, and then we take the closure under complementation, union, and concatenation. Intersection comes for free. For example, the regex (ab)* is in this class, but (aa)* is not.","related":["REG"],"children":["AC^0","REG"]},{"name":"SZK","equals":[],"properties":[],"notes":"todo def","desc":"Statistical Zero Knowledge. A promise problem is in SZK if there exists an interactive proof system (a polynomial-time probabilistic verifier interacting with a polynomial-time prover) such that: (1) For YES instances, there exists a polynomial-time prover that causes the verifier to accept with high probability; (2) For NO instances, for any prover, the verifier accepts with low probability; (3) For YES instances, there exists a polynomial-time simulator that, given only the input, can generate a transcript whose distribution is statistically indistinguishable from the verifier's view in the real protocol. That is, the verifier learns nothing beyond the validity of the statement. The protocol may be multi-round, and the zero-knowledge property is statistical (i.e., holds against computationally unbounded verifiers). SZK is closed under complement, has complete promise problems (Statistical Difference, Entropy Difference), and is contained in AM ∩ coAM, as well as CZK and QSZK. Contains PZK and NISZK. There exists an oracle relative to which SZK is not in BQP. Contained in DQP. If any hard-on-average language is in SZK, then one-way functions exist.","related":["CZK","coAM","PZK","DQP","QSZK","NISZK","AM"],"children":["DQP","QSZK","AM","coAM","CZK"]},{"name":"TC","equals":false,"properties":["circuit"],"notes":"","desc":"Threshold Circuits","related":["AC","NC","TC^0"],"children":[]},{"name":"TC^0","equals":[],"properties":["circuit"],"notes":"","desc":"Constant-Depth Threshold Circuits","related":["ACC^0","NC^0","AC^0","TC"],"children":["NC^1"]},{"name":"TC^1","equals":[],"properties":["circuit"],"notes":"","desc":"Log-Depth Threshold Circuits","related":["NC^0","AC^1","TC","TC^0"],"children":["NC^2"]},{"name":"TOWER","equals":[],"properties":[],"notes":"","desc":"Power-tower time. Solvable in time f(x), where f can be expressed using tetration (and +, *, ^, 0, 1).","related":["ELEMENTARY","PR"],"children":["PR"]},{"name":"ZBQP","equals":[],"properties":[],"notes":"","desc":"Strict Quantum {lang:ZPP}.\nDefined as {lang:RBQP} ∩ {lang:coRBQP}. Equivalently, the class of problems in {lang:NP} ∩ {lang:coNP} such that both positive and negative witnesses are in {lang:FBQP}.\nFor example, the language of square-free numbers is in {lang:ZBQP}, because factoring is in {lang:FBQP} and a factorization can be certified in ZPP (indeed in P, by {ref:AKS02}).\nUnlike {lang:EQP} or {lang:ZQP}, {lang:ZBQP} would generalize {lang:ZPP} in practice if quantum computers existed, in the sense that it provides proven answers. {thm:ZBQP^ZBQP = ZBQP}.","related":["RQP","EQP","ZQP","BQP"],"children":["coRBQP","RBQP"]},{"name":"ZPP","equals":[],"properties":[],"notes":"todo the polytime yes/no/unknown definition. todo the two-machine definition","desc":"Zero error Probabilistic Polynomial time. Problems with a probabilistic Turing machine with zero error and polynomial expected running time","related":["RP","BPP"],"children":["ZQP","RP","coRP","ZBQP"]},{"name":"ZPL","equals":[],"properties":[],"notes":"todo the yes/no/unknown definition. todo the two-machine definition","desc":"Zero error Probabilistic Logspace. Problems with a probabilistic Turing machine with zero error, logarithmic space, and a termination probability of 1","related":["coRL","RL","L"],"children":["RL","coRL"]},{"name":"ZQP","equals":[],"properties":[],"notes":"","desc":"Zero-Error Extension Of {lang:EQP}.\nThe class of questions that can be answered by a QTM that answers yes, no, or maybe. If the correct answer is yes, then P[no] = 0, and vice-versa; and the probability of maybe is at most 1/2. Since some of the probabilities have to vanish, ZQP has the same technical caveats as {lang:EQP}.\nDefined independently in {ref:BW03} and in {ref:Nis02}. Equals {lang:RQP} ∩ {lang:coRQP}. There is an oracle such that ZQP^{ZQP} is larger than ZQP {ref:BW03}.","related":["RQP","EQP","ZBQP","BQP"],"children":["RQP","coRQP"]},{"name":"StoqMA","equals":[],"properties":[],"notes":"Defined in [BBT07]. 2-local stoquastic Hamiltonian is StoqMA-complete. Transverse field Ising model is StoqMA-complete [BH16]. No strong error reduction known [AGL21]. Conjectured: StoqMA with strong error reduction = MA.","desc":"Stoquastic Merlin-Arthur. The class of decision problems solvable by a Merlin-Arthur protocol where the verifier is a polynomial-size stoquastic quantum circuit (i.e., all off-diagonal elements of the Hamiltonian are non-positive in the computational basis). Merlin sends a polynomial-size quantum proof, and Arthur (the verifier) accepts with probability at least α for YES instances and at most β for NO instances, with α−β ≥ 1/poly(n). The 2-local stoquastic Hamiltonian problem is complete for StoqMA. The transverse field Ising model is also StoqMA-complete. There is no known strong error reduction for StoqMA; it is conjectured that StoqMA with strong error reduction is equivalent to MA.","related":["MA","QMA"],"children":["QMA"]},{"name":"Δ2","equals":[],"properties":[],"notes":"","desc":"P^NP. The weakest class at the second level in the polynomial hierarchy.","related":["Π2","Σ2","PH"],"children":["Σ2","Π2"]},{"name":"Π2","equals":[],"properties":[],"notes":"","desc":"Universal polynomial time, 2 alternations. coNP^NP, at the second level in the polynomial hierarchy.","related":["Δ2","Σ2","PH"],"children":["PH"]},{"name":"Σ2","equals":[],"properties":[],"notes":"","desc":"Existential polynomial time, 2 alternations. NP^coNP, at the second level in the polynomial hierarchy.","related":["Π2","Δ2","PH"],"children":["PH"]},{"name":"nuACC^0","equals":[],"properties":["nonuniform"],"notes":"","desc":"{lang:ACC^0} but with no uniformity condition.","related":["ACC^0"],"children":["ALL"]}]