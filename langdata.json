[{"name":"A_0PP","equals":[],"desc":"TODO. Defined in {ref:Vya03}.","children":["PP"]},{"name":"AC","equals":false,"desc":"Unbounded Fanin Polylogarithmic-Depth Circuits. The class of decision problems solvable by a nonuniform family of Boolean circuits, with polynomial size, depth O(log^k(n)), and unbounded fanin, for some k. The gates allowed are AND, OR, and NOT. For a given k, we get AC^k, such as AC^1. The class AC^0 is when k=0 i.e. constant depth. Equal to NC and TC.","children":[]},{"name":"AC^0","equals":[],"desc":"Unbounded Fanin Constant-Depth Circuits. An especially important subclass of AC, corresponding to constant-depth, unbounded-fanin, polynomial-size circuits with AND, OR, and NOT gates.","children":["ACC^0"]},{"name":"AC^1","equals":[],"desc":"Unboudned Fanin Log-depth Circuits.","children":["TC^1"]},{"name":"ACC^0","equals":[],"desc":"AC0 With Arbitrary MOD Gates.","children":["TC^0"]},{"name":"ACKERMANN","equals":[],"desc":"Ackermann function time. Problems solvable by a Turing machine in time A(O(n),O(n)), where A is the Ackermann function. Reachability in vector addition systems is complete for this class, placing it strictly above PR.","children":["R"]},{"name":"ALL","equals":[],"desc":"All languages. Everything is contained in this class. Not considered feasible.","children":[]},{"name":"AM","equals":[],"desc":"Arthur-Merlin games. In general, AM[k] is k-round interactive protocols between am omniscient Merlin and a polytime Arthur. Arthur has randomness, but Merlin can see all of Arthur's randomness, and they exchange polynomial size messages, and Arthur becomes convinced with 2/3 soundness and completeness. It turns out that AM[k]=AM[2] for any constant k, TODO reference, and then the class AM is defined as AM[2]. This doesn't translate to polynomial k, as the message sizes grows by at least a constant factor with each removed round, leading to exponential slowdown if you tried to run AM[poly] as a AM[2] protocol. As other cases, there are AM[0]=BPP, AM[1]=MA, and AM[poly(n)]=IP. There is also the odd one AM[polylog(n)].\n Compare with IP[k], which has private coins: Merlin can't see Arthur's random choices.","children":["Π2"]},{"name":"AP","equals":false,"desc":"Alternating polynomial time. Polynomial time with unlimited switches between an \"NP\"-like \"OR\" mode, and a coNP \"AND\" mode.","children":[]},{"name":"AWPP","equals":[],"desc":"TODO","children":["A_0PP"]},{"name":"BPP","equals":[],"desc":"Bounded error Probabilistic Polynomial time. Problems with a probabilistic polynomial-time Turing machine with at least a 2/3 chance of a correct answer.","children":["NISQ","Π2","Σ2"]},{"name":"BQP","equals":[],"desc":"TODO","children":["QCMA","DQP","AWPP"]},{"name":"CFL","equals":[],"desc":"Context-Free languages","children":["SAC^1"]},{"name":"CH","equals":[],"desc":"Counting Hierarchy. Union of PP, PP^PP, PP^(PP^PP), and so on. With the counting operator C[M] = PP^M, we can say that CH = C^O(1)[P], analogous to how PH = Σ^O(1)[P] = Π^O(1)[P]","children":["PSPACE"]},{"name":"coAM","equals":[],"desc":"Complement of Arthur-Merlin games","children":["Σ2"]},{"name":"coNL","equals":false,"desc":"Complement of Nondeterministic Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.","children":[]},{"name":"coMA","equals":[],"desc":"Complement of Merlin-Arthur games","children":["coAM"]},{"name":"coNP","equals":[],"desc":"Complement of Nondeterministic Polynomial time. Problems whose complement decided in polynomial time by a nondeterministic Turing machine.","children":["Δ2","coMA"]},{"name":"coRE","equals":[],"desc":"Complement of Recursively enumerable languages. Languages whose rejection can be recognized by a Turing machine.","children":["ALL"]},{"name":"coRP","equals":[],"desc":"Complement of Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine with zero error on YES instances","children":["BPP","coNP"]},{"name":"DET","equals":[],"desc":"Problems L-reducible to computing the determinant of an n-by-n matrix of n-bit integers. ComplexityZoo says the corresponding function class is GapL (TODO ref).","children":["NC^2"]},{"name":"DQC1","equals":[],"desc":"Deterministic Quantum Computing with 1 Clean Bit. The class of problems solvable by a BQP machine in which a single qubit is initialized to the '0' state, and the remaining qubits are initialized to the maximally mixed state. Defined in {ref:KL98}. This has been called BQ1P, sometimes, to distinguish it from the _sampling_ problem of DQC1 circuits. Since \"DQC1\" seems to have stuck, we call the sampling problem DQC1S.","children":["BQP"]},{"name":"DQP","equals":[],"desc":"Dynamical Quantum Polynomial-Time.The class of decision problems solvable by a BQP machine with oracle access to a dynamical simulator. When given a polynomial-size quantum circuit, the simulator returns a sample from the distribution over \"classical histories\" induced by the circuit. The simulator can adversarially choose any history distribution that satisfies the axioms of \"symmetry\" and \"locality\" -- so that the DQP algorithm has to work for any distribution satisfying these axioms. Defined in {ref:Aar05}.","children":["EXP"]},{"name":"E","equals":[],"desc":"(Linear) Exponential time. Problems decided in exponential time with linear exponent, by a deterministic Turing machine.","children":["EXP"]},{"name":"ELEMENTARY","equals":[],"desc":"Elementary languages. The union of EXP, EEXP, EEXP, etc.: solvable by a Turing machine with runtime 2^n, 2^(2^n), 2^(2^(2^n)) for some height. Equivalently, DTIME(^{O(1)}n), where ^{a}b indicates the tetration of b to the height a.","children":["TOWER"]},{"name":"EQP","equals":[],"desc":"TODO","children":["BQP"]},{"name":"EXP","equals":[],"desc":"Exponential time. Problems decided in singly exponential time by a deterministic Turing machine.","children":["NEXP"]},{"name":"GA","equals":[],"desc":"Graph Automorphism. Languages that can be polynomial-time Turing reduced to Graph Automorphism. Compare with GI for isomorphism, and GAK for Karp reductions.","children":["GI"]},{"name":"GAK","equals":[],"desc":"Graph Automorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.","children":["GA"]},{"name":"GI","equals":[],"desc":"Graph Isomorphism. Languages that can be polynomial-time Turing reduced to Graph Isomorphism. This is, in some sense, a powerful reduction; compare with GIK for Karp reductions. Compare with GA which only allows automorphism checking.","children":["Δ2"]},{"name":"GIK","equals":[],"desc":"Graph Isomorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.","children":["NP","SZK","GI"]},{"name":"IP","equals":false,"desc":"Interactive Proofs. In general, IP[r] means a proof where a player exchanges r rounds with a polynomial time verifier; the verifier has private random coins. The class IP is defined as IP[poly(n)], and it turns out that IP=PSPACE, see {ref:Sha90}. For IP[r] with a constant r, it turns to be equal to AM; see AM for more. {ref:BM88} also proved that IP[f(n)]=IP[c*f(n)].","children":[]},{"name":"L","equals":[],"desc":"Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.","children":["DQC1","RL"]},{"name":"LOGCFL","equals":false,"desc":"The class of decision problems reducible in L to the problem of deciding membership in a context-free language. In order words, the closure under L-reductions of {lang:CFL}. Equivalently, LOGCFL is the class of decision problems solvable by a _uniform_ family of AC1 circuits, in which no AND gate has fan-in exceeding 2, see {ref:Joh90}{ref:Ven91}. When the circuits aren't uniform, we get the LOGCFL/poly = SAC^1, see {lang:SAC^1}.","children":[]},{"name":"MA","equals":[],"desc":"Merlin-Arthur games","children":["QCMA","SBP"]},{"name":"MIP","equals":false,"desc":"Multiple-player Interactive Proofs. In general, MIP[p,r] means a proof with p player who cannot communicate, and r rounds of interaction with a referee. (The final round is always a message to the referee, as a final message to a player cannot be useful.) As it turns out, MIP[p,r]=MIP[2,1] for any p>=2 and r>=1, so the distinction is largely unnecessary. MIP[1,r] is better known as AM[r], see AM for more. \n And of course MIP[p,0] is just P. :)\n\nMIP[p,r]=MIP[2,poly] is proved in {ref:BFL91}. I can't find a source for the statement that MIP[2,poly]=MIP[2,1].","children":[]},{"name":"MIP*","equals":false,"desc":"Multiple-player Interactive Proofs, with entanglement. Traditionally defined with polynomially many players and rounds, but it turns out that MIP*[poly,poly]=MIP*[2,1], so one can just think of as two players and one round. \n When the provers are allowed to have (unbounded) entanglement, this allows them to cheat at some games, so it is not obvious that MIP* is as big as MIP; it is only clear that one can ignore all but one player and get the class IP as a lower bound. But, having entanglement also means we can ask more from the players -- much more, and it turns out that MIP*=RE, and includes undecidable problems.","children":[]},{"name":"MIPco","equals":[],"desc":"Multiple-player Interactive Proofs, with entanglement, in the _commuting_ operator framework. This was expected to be equal to MIP*, but this isn't the case: MIP*=RE, while MIPco is contained in coRE. (It is expected that MIPco=coRE.) Nothing contained in coRE can equal RE!","children":["coRE"]},{"name":"NC","equals":["AC","TC"],"desc":"Nick's Class","children":["RNC","P"]},{"name":"NC^0","equals":["RNC^0"],"desc":"Constant-Depth Nick's Class: uniform constant depth circuits with bounded-fanin gates. By definition, a decision problem in NC0 can depend on only a constant number of bits of the input. Thus, NC^0 often refers to functions computable by constant-depth, bounded-fanin circuits, as it crops up in NC^0 reduction. Here we call that class of functions FNC^0 instead.","children":["SAC^0","QNC^0"]},{"name":"NC^1","equals":[],"desc":"Log-Depth Nick's Class","children":["SAC^1","L","RNC^1"]},{"name":"NC^2","equals":[],"desc":"Log^2-Depth Nick's Class","children":["NC"]},{"name":"NEXP","equals":["MIP"],"desc":"Nondeterministic Exponential Time; also called NEXPTIME. Equivalently, problems with an EXP-size witness that can be verified by a polytime verifier (whose runtime is polynomial in the size of the input *and* the witness).","children":["MIPco","ELEMENTARY"]},{"name":"NISQ","equals":[],"desc":"Problems solvable by a classical computer in poly(n) time with poly(n) queries to an λ-NQC oracle, which outputs samples from a λ-noisy quantum circuit: after each gate single gate, a λ-noise depolarizing channel is applied simultaneously to every qubit.","children":["BQP"]},{"name":"NL","equals":["coNL"],"desc":"Nondeterministic Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.","children":["DET","AC^1"]},{"name":"NP","equals":[],"desc":"Nondeterministic Polynomial time. Problems decided in polynomial time by a nondeterministic Turing machine.","children":["NQP","Δ2","MA"]},{"name":"NQP","equals":[],"desc":"Nondeterministic Quantum Polynomial time. The class of decision problems solvable by a QTM in polynomial time such that a particular \"|Accept>\" state has nonzero amplitude at the end of the computation, if and only if the answer is \"yes.\"","children":["A_0PP"]},{"name":"P","equals":[],"desc":"Polynomial time. Problems decided in polynomial time by a deterministic Turing machine.","children":["EQP","GAK","E","ZPP","GIK"]},{"name":"PARITY","equals":[],"desc":"The single language asking, 'Is the number of 1s in the input an even number'?","children":["REG","ACC^0"]},{"name":"PH","equals":[],"desc":"Polynomial hierarchy","children":["PSPACE"]},{"name":"PP","equals":[],"desc":"Probabilistic Polynomial time.","children":["CH"]},{"name":"PR","equals":[],"desc":"Primitive Recursive. Languages decidable in time bounded by a primitive recursive function of natural numbers.","children":["ACKERMANN"]},{"name":"PSPACE","equals":["AP","IP","QIP"],"desc":"Polynomial space. Problems decided in polynomial space by a deterministic Turing machine.","children":["EXP"]},{"name":"QCMA","equals":[],"desc":"Quantum-Classical Merlin-Arthur. Like QMA, but Merlin's proof is a classical string; like NP, but the verifier has a quantum computer (BQP machine).","children":["QMA"]},{"name":"QIP","equals":false,"desc":"Quantum Interactive Proofs. Like IP, but now messages can be quanutum. Only a single prover. For a different kind of 'quantum' interactive proof, there's the much harder MIP* and MIPco.","children":[]},{"name":"QMA","equals":[],"desc":"Quantum Merlin-Arthur. Problems for which an omniscient 'Merlin' can submit a proof to 'Arthur' that a statement is true, and Arthur believes it with high probability (<1/3 chance of failing) -- but this proof can be a quantum state, and Arthur has a quantum computer.","children":["A_0PP"]},{"name":"QNC","equals":[],"desc":"The class of decision problems solvable by polylogarithmic-depth quantum circuits with bounded probability of error. The zoo says, \"A uniformity condition may also be imposed.\"; for the purpose of this site we _do_ impose that condition. Some sources like https://dl.acm.org/doi/10.1145/3570637 refer to this as BQNC.","children":["BQP"]},{"name":"QNC^0","equals":[],"desc":"Constant-depth quantum circuits","children":["QNC^1"]},{"name":"QNC^1","equals":[],"desc":"Log-depth quantum circuits","children":["QNC"]},{"name":"R","equals":[],"desc":"Recursive languages. RE∩coRE. Languages solvable by a Turing machine.","children":["RE","coRE"]},{"name":"RE","equals":["MIP*"],"desc":"Recursively enumerable languages. Languages whose acceptance can be recognized by a Turing machine.","children":["ALL"]},{"name":"REG","equals":[],"desc":"Regular languages","children":["CFL","NC^1"]},{"name":"RL","equals":[],"desc":"Randomized Logspace. Problems with a probabilistic logarithmic-space Turing machine with zero error on NO instances (and, technically, a termination probability of 1 on all inputs).","children":["NL"]},{"name":"RP","equals":[],"desc":"Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine with zero error on NO instances","children":["BPP","NP"]},{"name":"RNC","equals":[],"desc":"Randomized Nick's Class. The class of decision problems solvable by polylogarithmic-depth random circuits with bounded one-sided probability of error: it must never incorrectly accept, and it must correctly reject at least 1/2 of the time.","children":["RP","QNC"]},{"name":"RNC^0","equals":false,"desc":"Randomized constant-depth circuits of bounded-fanin. Not very interesting because the randomness cannot be useful, so this is equal to NC^0. But the functional version FRNC^0 is slightly more interesting (in the same way that FNC^0 is more interesting than NC^0) and has been used in reductions, e.g. https://drops.dagstuhl.de/opus/volltexte/2023/17506/pdf/LIPIcs-ITCS-2023-3.pdf","children":[]},{"name":"RNC^1","equals":[],"desc":"Randomized log-depth circuits of bounded-fanin.","children":["QNC^1","RNC"]},{"name":"SAC^0","equals":[],"desc":"SAC^k is the class of decision problems solvable by a family of depth-O(logkn) circuits with unbounded-fanin OR & bounded-fanin AND gates. Negations are only allowed at the input level. A uniformity condition may also be imposed. SAC^k sits naturally 'halfway' between NC^k and AC^k.","children":["AC^0"]},{"name":"SAC^1","equals":["LOGCFL"],"desc":"Semi-Unbounded-Fanin AC^1. See {ref:SAC^0} for definition. SAC^1 (with a uniformity condition) = LOGCFL, and without a uniformity condition = LOGCFL/poly, see {ref:Joh90}{ref:Ven91}.","children":["AC^1"]},{"name":"SBP","equals":[],"desc":"Small Bounded-Error Probability. The class of decision problems for which the following holds. There exists a #P function f and an FP function g such that, for all inputs x,\n If the answer is \"yes\" then f(x) > g(x).\n If the answer is \"no\" then f(x) < g(x)/2.\n Defined in {ref:BGM02}.","children":["A_0PP","AM"]},{"name":"SF","equals":[],"desc":"Star-free languages, see https://en.wikipedia.org/wiki/Star-free_language. A subset of regular languages, where constant terms are allowed, and then we take the closure under complementation, union, and concatenation. Intersection comes for free. For example, the regex (ab)* is in this class, but (aa)* is not.","children":["AC^0","REG"]},{"name":"SZK","equals":[],"desc":"Statistical Zero Knowledge.","children":["DQP","AM","coAM"]},{"name":"TC","equals":false,"desc":"Threshold Circuits","children":[]},{"name":"TC^0","equals":[],"desc":"Constant-Depth Threshold Circuits","children":["NC^1"]},{"name":"TC^1","equals":[],"desc":"Log-Depth Threshold Circuits","children":["NC^2"]},{"name":"TOWER","equals":[],"desc":"Power-tower time. Solvable in time f(x), where f can be expressed using tetration (and +, *, ^, 0, 1).","children":["PR"]},{"name":"ZPP","equals":[],"desc":"Zero error Probabilistic Polynomial time. Problems with a probabilistic Turing machine with zero error and polynomial expected running time","children":["coRP","RP"]},{"name":"Δ2","equals":[],"desc":"P^NP. The weakest class at the second level in the polynomial hierarchy.","children":["Σ2","Π2"]},{"name":"Π2","equals":[],"desc":"Universal polynomial time, 2 alternations. coNP^NP, at the second level in the polynomial hierarchy.","children":["PH"]},{"name":"Σ2","equals":[],"desc":"Existential polynomial time, 2 alternations. NP^coNP, at the second level in the polynomial hierarchy.","children":["PH"]}]