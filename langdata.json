[{"name":"A_0PP","equals":[],"properties":[],"notes":"","desc":"TODO. Defined in {ref:Vya03}.","related":["SBP","PP","AWPP"],"children":["PP"]},{"name":"AC","equals":false,"properties":[],"notes":"","desc":"Unbounded Fanin Polylogarithmic-Depth Circuits. The class of decision problems solvable by a nonuniform family of Boolean circuits, with polynomial size, depth O(log^k(n)), and unbounded fanin, for some k. The gates allowed are AND, OR, and NOT. For a given k, we get AC^k, such as AC^1. The class AC^0 is when k=0 i.e. constant depth. Equal to NC and TC.","related":["NC","AC^0","AC^1","TC"],"children":[]},{"name":"AC^0","equals":[],"properties":[],"notes":"","desc":"Unbounded Fanin Constant-Depth Circuits. An especially important subclass of AC, corresponding to constant-depth, unbounded-fanin, polynomial-size circuits with AND, OR, and NOT gates.","related":["NC","NC^0","AC^1","AC^0"],"children":["ACC^0"]},{"name":"AC^1","equals":[],"properties":[],"notes":"","desc":"Unboudned Fanin Log-depth Circuits.","related":["AC","TC^1","NC^1","AC^0"],"children":["TC^1"]},{"name":"ACC^0","equals":[],"properties":[],"notes":"","desc":"AC0 With Arbitrary MOD Gates. Polynomial size, constant depth.","related":["AC^0","TC^0"],"children":["nuACC^0","TC^0"]},{"name":"ACKERMANN","equals":[],"properties":[],"notes":"","desc":"Ackermann function time. Problems solvable by a Turing machine in time A(O(n),O(n)), where A is the Ackermann function. Reachability in vector addition systems is complete for this class, placing it strictly above PR.","related":["PR"],"children":["R"]},{"name":"ALL","equals":[],"properties":[],"notes":"","desc":"All languages. Everything is contained in this class. Not considered feasible.","related":["RE","R"],"children":[]},{"name":"AM","equals":[],"properties":[],"notes":"todo def","desc":"Arthur-Merlin games. In general, AM[k] is k-round interactive protocols between am omniscient Merlin and a polytime Arthur. Arthur has randomness, but Merlin can see all of Arthur's randomness, and they exchange polynomial size messages, and Arthur becomes convinced with 2/3 soundness and completeness. It turns out that AM[k]=AM[2] for any constant k, TODO reference, and then the class AM is defined as AM[2]. This doesn't translate to polynomial k, as the message sizes grows by at least a constant factor with each removed round, leading to exponential slowdown if you tried to run AM[poly] as a AM[2] protocol. As other cases, there are AM[0]=BPP, AM[1]=MA, and AM[poly(n)]=IP. There is also the odd one AM[polylog(n)].\n Compare with IP[k], which has private coins: Merlin can't see Arthur's random choices.","related":["NP","IP","MA"],"children":["Π2"]},{"name":"AP","equals":false,"properties":[],"notes":"todo def","desc":"Alternating polynomial time. Polynomial time with unlimited switches between an \"NP\"-like \"OR\" mode, and a coNP \"AND\" mode.","related":["PSPACE","PH"],"children":[]},{"name":"AWPP","equals":[],"properties":[],"notes":"","desc":"TODO","related":["A_0PP","SBP"],"children":["A_0PP"]},{"name":"BPP","equals":[],"properties":[],"notes":"","desc":"Bounded error Probabilistic Polynomial time. Problems with a probabilistic polynomial-time Turing machine with at least a 2/3 chance of a correct answer.","related":["RP","PromiseBPP","ZPP"],"children":["NISQ","Π2","Σ2"]},{"name":"BQP","equals":[],"properties":[],"notes":"","desc":"TODO","related":["EQP","NISQ","IQP","BPP","QMA"],"children":["QCMA","DQP","AWPP"]},{"name":"CFL","equals":[],"properties":[],"notes":"","desc":"Context-Free languages","related":["CSL","REG"],"children":["NLINSPACE","SAC^1"]},{"name":"CH","equals":[],"properties":[],"notes":"","desc":"Counting Hierarchy. Union of PP, PP^PP, PP^(PP^PP), and so on. With the counting operator C[M] = PP^M, we can say that CH = C^O(1)[P], analogous to how PH = Σ^O(1)[P] = Π^O(1)[P]","related":["PP"],"children":["PSPACE"]},{"name":"CSL","equals":false,"properties":[],"notes":"","desc":"Context-Sensitive languages. Precisely the languages that can be described by a https://en.wikipedia.org/wiki/Context-sensitive_grammar. Equal to {lang:NLINSPACE}, see {thm:CSL=NLINSPACE}.","related":["CFL","REG"],"children":[]},{"name":"coAM","equals":[],"properties":[],"notes":"todo def","desc":"Complement of Arthur-Merlin games, {lang:AM}.","related":["coMA","AM"],"children":["Σ2"]},{"name":"coNL","equals":false,"properties":[],"notes":"","desc":"Complement of Nondeterministic Logarithmic space, {lang:NL}. Problems decided in logarithmic space by a deterministic Turing machine. Actually equal to {lang:NL}, a consequence of {thm:Immerman–Szelepcsényi theorem}.","related":[],"children":[]},{"name":"coMA","equals":[],"properties":[],"notes":"todo def. todo coMA=coMA1","desc":"Complement of Merlin-Arthur games, {lang:MA}.","related":["coAM","MA"],"children":["coAM"]},{"name":"coNP","equals":[],"properties":[],"notes":"todo: verifier definition","desc":"Complement of Nondeterministic Polynomial time, {lang:coNP}. Problems whose complement decided in polynomial time by a nondeterministic Turing machine; or equivalently, problems that can be disproved by a polynomial-time checkable witness.","related":[],"children":["Δ2","coMA"]},{"name":"coRE","equals":[],"properties":[],"notes":"todo: definition as a Turing machine","desc":"Complement of Recursively enumerable languages, {lang:RE}. Languages whose rejection can be recognized by a Turing machine.","related":["RE"],"children":["ALL"]},{"name":"coRP","equals":[],"properties":[],"notes":"todo: complement of RP","desc":"Complement of Randomized Polynomial time, {lang:RP}. Problems with a probabilistic polynomial-time Turing machine with zero error on YES instances","related":["RP"],"children":["BPP","coNP"]},{"name":"DET","equals":[],"properties":[],"notes":"","desc":"Problems L-reducible to computing the determinant of an n-by-n matrix of n-bit integers. ComplexityZoo says the corresponding function class is GapL (TODO ref).","related":["NC^2","NL"],"children":["NC^2"]},{"name":"DQC1","equals":[],"properties":[],"notes":"","desc":"Deterministic Quantum Computing with 1 Clean Bit. The class of problems solvable by a BQP machine in which a single qubit is initialized to the '0' state, and the remaining qubits are initialized to the maximally mixed state. Defined in {ref:KL98}. This has been called BQ1P, sometimes, to distinguish it from the _sampling_ problem of DQC1 circuits. Since \"DQC1\" seems to have stuck, we call the sampling problem DQC1S.","related":["DQC1S","BQP"],"children":["BQP"]},{"name":"DQP","equals":[],"properties":[],"notes":"","desc":"Dynamical Quantum Polynomial-Time.The class of decision problems solvable by a BQP machine with oracle access to a dynamical simulator. When given a polynomial-size quantum circuit, the simulator returns a sample from the distribution over \"classical histories\" induced by the circuit. The simulator can adversarially choose any history distribution that satisfies the axioms of \"symmetry\" and \"locality\" -- so that the DQP algorithm has to work for any distribution satisfying these axioms. Defined in {ref:Aar05}.","related":["BQP"],"children":["EXP"]},{"name":"E","equals":[],"properties":[],"notes":"","desc":"(Linear) Exponential time. Problems decided in exponential time with linear exponent, by a deterministic Turing machine.","related":[],"children":["EXP"]},{"name":"ELEMENTARY","equals":[],"properties":[],"notes":"","desc":"Elementary languages. The union of EXP, EEXP, EEXP, etc.: solvable by a Turing machine with runtime 2^n, 2^(2^n), 2^(2^(2^n)) for some height. Equivalently, DTIME(^{O(1)}n), where ^{a}b indicates the tetration of b to the height a.","related":["EXP"],"children":["TOWER"]},{"name":"EQP","equals":[],"properties":[],"notes":"","desc":"TODO","related":["BQP"],"children":["BQP"]},{"name":"EXP","equals":[],"properties":[],"notes":"","desc":"Exponential time. Problems decided in singly exponential time by a deterministic Turing machine.","related":[],"children":["NEXP"]},{"name":"GA","equals":[],"properties":[],"notes":"","desc":"Graph Automorphism. Languages that can be polynomial-time Turing reduced to Graph Automorphism. Compare with GI for isomorphism, and GAK for Karp reductions.","related":["GI","GAK"],"children":["GI"]},{"name":"GAK","equals":[],"properties":[],"notes":"","desc":"Graph Automorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.","related":["GIK","GA"],"children":["GA"]},{"name":"GI","equals":[],"properties":[],"notes":"","desc":"Graph Isomorphism. Languages that can be polynomial-time Turing reduced to Graph Isomorphism. This is, in some sense, a powerful reduction; compare with GIK for Karp reductions. Compare with GA which only allows automorphism checking.","related":["GIK","GA"],"children":["Δ2"]},{"name":"GIK","equals":[],"properties":[],"notes":"","desc":"Graph Isomorphism with Karp reductions. Languages that can be polynomial-time Karp reduced to Graph Automorphism.","related":["GI","GAK"],"children":["NP","SZK","GI"]},{"name":"IP","equals":false,"properties":[],"notes":"","desc":"Interactive Proofs. In general, IP[r] means a proof where a player exchanges r rounds with a polynomial time verifier; the verifier has private random coins. The class IP is defined as IP[poly(n)], and it turns out that IP=PSPACE, see {ref:Sha90}. For IP[r] with a constant r, it turns to be equal to AM; see AM for more. {ref:BM88} also proved that IP[f(n)]=IP[c*f(n)].","related":["MIP","QIP","PSPACE","AM"],"children":[]},{"name":"L","equals":[],"properties":[],"notes":"todo SL","desc":"Logarithmic space. Problems decided in logarithmic space by a deterministic Turing machine.","related":[],"children":["LINSPACE","DQC1","RL"]},{"name":"LINSPACE","equals":[],"properties":[],"notes":"","desc":"Deterministic Linear space. Problems decided in linear space by a deterministic Turing machine.","related":["NLINSPACE","PSPACE"],"children":["PSPACE"]},{"name":"LOGCFL","equals":false,"properties":[],"notes":"","desc":"The class of decision problems reducible in L to the problem of deciding membership in a context-free language. In order words, the closure under L-reductions of {lang:CFL}. Equivalently, LOGCFL is the class of decision problems solvable by a _uniform_ family of AC1 circuits, in which no AND gate has fan-in exceeding 2, see {ref:Joh90}{ref:Ven91}. When the circuits aren't uniform, we get the LOGCFL/poly = SAC^1, see {lang:SAC^1}.","related":["CFL","SAC^1"],"children":[]},{"name":"MA","equals":[],"properties":[],"notes":"todo def. todo MA=MA1","desc":"Merlin-Arthur games","related":["NP","AM","QMA"],"children":["QCMA","SBP"]},{"name":"MIP","equals":false,"properties":[],"notes":"","desc":"Multiple-player Interactive Proofs. In general, MIP[p,r] means a proof with p player who cannot communicate, and r rounds of interaction with a referee. (The final round is always a message to the referee, as a final message to a player cannot be useful.) As it turns out, MIP[p,r]=MIP[2,1] for any p>=2 and r>=1, so the distinction is largely unnecessary. MIP[1,r] is better known as AM[r], see AM for more. \n And of course MIP[p,0] is just P. :)\n\nMIP[p,r]=MIP[2,poly] is proved in {ref:BFL91}. I can't find a source for the statement that MIP[2,poly]=MIP[2,1].","related":["IP","QIP","NEXP","AM","MIP*","MIPco"],"children":[]},{"name":"MIP*","equals":false,"properties":[],"notes":"","desc":"Multiple-player Interactive Proofs, with entanglement. Traditionally defined with polynomially many players and rounds, but it turns out that MIP*[poly,poly]=MIP*[2,1], so one can just think of as two players and one round. \n When the provers are allowed to have (unbounded) entanglement, this allows them to cheat at some games, so it is not obvious that MIP* is as big as {lang:MIP}; it is only clear that one can ignore all but one player and get the class IP as a lower bound. But, having entanglement also means we can ask more from the players -- much more, and it turns out that {thm:MIP*=RE}, and includes undecidable problems.","related":["RE","MIP","MIPco"],"children":[]},{"name":"MIPco","equals":[],"properties":[],"notes":"","desc":"Multiple-player Interactive Proofs, with entanglement, in the _commuting_ operator framework. This was expected to be equal to {lang:MIP*}, but this isn't the case: {thm:MIP*=RE}, while MIPco is contained in {lang:coRE}. (It is expected that MIPco=coRE.) Nothing contained in coRE can equal RE!","related":["coRE","MIPco","MIP*"],"children":["coRE"]},{"name":"NC","equals":["AC","TC"],"properties":[],"notes":"","desc":"Nick's Class","related":["AC","NC^0","TC"],"children":["RNC","P"]},{"name":"NC^0","equals":["RNC^0"],"properties":[],"notes":"","desc":"Constant-Depth Nick's Class: uniform constant depth circuits with bounded-fanin gates. By definition, a decision problem in NC0 can depend on only a constant number of bits of the input. For that reason, \"NC^0\" is often used to refer to _functions_ computable by constant-depth, bounded-fanin circuits, instead of _decision_ problem. This comes up in NC^0 reduction. We opt to call that class of functions {lang:FNC^0} instead.","related":["NC","NC^1","FNC^0","AC^0","TC^0"],"children":["SAC^0","QNC^0"]},{"name":"NC^1","equals":[],"properties":[],"notes":"","desc":"Log-Depth Nick's Class","related":["TC^1","NC","NC^0","AC^1"],"children":["SAC^1","L","RNC^1"]},{"name":"NC^2","equals":[],"properties":[],"notes":"","desc":"Log^2-Depth Nick's Class","related":["DET","NC","AC^1"],"children":["NC"]},{"name":"NEXP","equals":["MIP"],"properties":[],"notes":"","desc":"Nondeterministic Exponential Time; also called NEXPTIME. Equivalently, problems with an EXP-size witness that can be verified by a polytime verifier (whose runtime is polynomial in the size of the input *and* the witness).","related":["EXP","NP"],"children":["MIPco","ELEMENTARY"]},{"name":"NISQ","equals":[],"properties":[],"notes":"","desc":"Problems solvable by a classical computer in poly(n) time with poly(n) queries to an λ-NQC oracle, which outputs samples from a λ-noisy quantum circuit: after each gate single gate, a λ-noise depolarizing channel is applied simultaneously to every qubit.","related":["IQP","BQP"],"children":["BQP"]},{"name":"NL","equals":["coNL"],"properties":[],"notes":"","desc":"Nondeterministic Logarithmic space. Problems decided in logarithmic space by a nondeterministic Turing machine.","related":[],"children":["NLINSPACE","DET","AC^1"]},{"name":"NLINSPACE","equals":["CSL"],"properties":[],"notes":"","desc":"Nondeterministic Linear space. Problems decided in linear space by a nondeterministic Turing machine. Equal to {lang:CSL}, the context-sensitive languages.","related":["LINSPACE","CSL","NPSPACE"],"children":["PSPACE"]},{"name":"NP","equals":[],"properties":[],"notes":"todo: verifier definition","desc":"Nondeterministic Polynomial time. Problems decided in polynomial time by a nondeterministic Turing machine.","related":[],"children":["NQP","Δ2","MA"]},{"name":"NPSPACE","equals":false,"properties":[],"notes":"","desc":"Nondeterministic polynomial space. Problems decided in polynomial space by a nondeterministic Turing machine. Actually equal to {lang:PSPACE}, as proved by {thm:Savitch's theorem}.","related":["NLINSPACE","PSPACE"],"children":[]},{"name":"NQP","equals":[],"properties":[],"notes":"","desc":"Nondeterministic Quantum Polynomial time. The class of decision problems solvable by a QTM in polynomial time such that a particular \"|Accept>\" state has nonzero amplitude at the end of the computation, if and only if the answer is \"yes.\"","related":["BQP","QMA"],"children":["A_0PP"]},{"name":"P","equals":[],"properties":[],"notes":"","desc":"Polynomial time. Problems decided in polynomial time by a deterministic Turing machine.","related":[],"children":["EQP","GAK","E","ZPP","GIK"]},{"name":"PARITY","equals":[],"properties":[],"notes":"","desc":"The single language asking, 'Is the number of 1s in the input an even number'?","related":[],"children":["REG","ACC^0"]},{"name":"PH","equals":[],"properties":[],"notes":"todo","desc":"Polynomial hierarchy","related":["Δ2","PP"],"children":["PSPACE"]},{"name":"PP","equals":[],"properties":[],"notes":"todo","desc":"Probabilistic Polynomial time.","related":["BPP"],"children":["CH"]},{"name":"PR","equals":[],"properties":[],"notes":"todo define PR *functions*","desc":"Primitive Recursive. Languages decidable in time bounded by a primitive recursive function of natural numbers.","related":["ELEMENTARY","ACKERMANN"],"children":["ACKERMANN"]},{"name":"PSPACE","equals":["AP","IP","NPSPACE","QIP"],"properties":[],"notes":"","desc":"Polynomial space. Problems decided in polynomial space by a deterministic Turing machine.","related":["AP","PH"],"children":["EXP"]},{"name":"QCMA","equals":[],"properties":[],"notes":"","desc":"Quantum-Classical Merlin-Arthur. Like {lang:QMA}, but Merlin's proof is a classical string; like NP, but the verifier has a quantum computer (a {lang:BQP} machine).","related":["QMA"],"children":["QMA"]},{"name":"QIP","equals":false,"properties":[],"notes":"","desc":"Quantum Interactive Proofs. Like {lang:IP}, but now messages can be quanutum. Only a single prover. For a different kind of 'quantum' interactive proof, there's the much harder {lang:MIP*} and {lang:MIPco}.","related":["IP","MIPco","MIP*"],"children":[]},{"name":"QMA","equals":[],"properties":[],"notes":"","desc":"Quantum Merlin-Arthur. Problems for which an omniscient 'Merlin' can submit a proof to 'Arthur' that a statement is true, and Arthur believes it with high probability (<1/3 chance of failing) -- but this proof can be a quantum state, and Arthur has a quantum computer.","related":["QCMA","BQP"],"children":["A_0PP"]},{"name":"QNC","equals":[],"properties":[],"notes":"","desc":"The class of decision problems solvable by polylogarithmic-depth quantum circuits with bounded probability of error. The zoo says, \"A uniformity condition may also be imposed.\"; for the purpose of this site we _do_ impose that condition. Some sources like https://dl.acm.org/doi/10.1145/3570637 refer to this as BQNC.","related":["RNC","NC","BQP"],"children":["BQP"]},{"name":"QNC^0","equals":[],"properties":[],"notes":"","desc":"Constant-depth quantum circuits","related":["QNC^0","QNC"],"children":["QNC^1"]},{"name":"QNC^1","equals":[],"properties":[],"notes":"","desc":"Log-depth quantum circuits","related":["QNC^0","QNC"],"children":["QNC"]},{"name":"R","equals":[],"properties":[],"notes":"todo: definition as a Turing machine, definition as intersection","desc":"Recursive languages. {lang:RE}∩{lang:coRE}. Languages solvable by a Turing machine.","related":["RE"],"children":["RE","coRE"]},{"name":"RE","equals":["MIP*"],"properties":[],"notes":"todo: definition as a Turing machine","desc":"Recursively enumerable languages. Languages whose acceptance can be recognized by a Turing machine.","related":["R"],"children":["ALL"]},{"name":"REG","equals":[],"properties":[],"notes":"","desc":"Regular languages","related":["CFL"],"children":["CFL","NC^1"]},{"name":"RL","equals":[],"properties":[],"notes":"todo: complement of coRL","desc":"Randomized Logspace. Problems with a probabilistic logarithmic-space Turing machine with zero error on NO instances (and, technically, a termination probability of 1 on all inputs).","related":["RP","L","NL"],"children":["NL"]},{"name":"RP","equals":[],"properties":[],"notes":"todo: complement of coRP","desc":"Randomized Polynomial time. Problems with a probabilistic polynomial-time Turing machine with zero error on NO instances","related":["coRP","BPP","ZPP"],"children":["BPP","NP"]},{"name":"RNC","equals":[],"properties":[],"notes":"todo: complement of coRNC","desc":"Randomized Nick's Class. The class of decision problems solvable by polylogarithmic-depth random circuits with bounded one-sided probability of error: it must never incorrectly accept, and it must correctly reject at least 1/2 of the time.","related":["RP","NC","QNC"],"children":["RP","QNC"]},{"name":"RNC^0","equals":false,"properties":[],"notes":"","desc":"Randomized constant-depth circuits of bounded-fanin. Not very interesting because the randomness cannot be useful, so this is equal to NC^0. But the functional version FRNC^0 is slightly more interesting (in the same way that FNC^0 is more interesting than NC^0) and has been used in reductions, e.g. https://drops.dagstuhl.de/opus/volltexte/2023/17506/pdf/LIPIcs-ITCS-2023-3.pdf","related":["RNC","RNC^1"],"children":[]},{"name":"RNC^1","equals":[],"properties":[],"notes":"","desc":"Randomized log-depth circuits of bounded-fanin.","related":["RNC^0","RNC"],"children":["QNC^1","RNC"]},{"name":"SAC^0","equals":[],"properties":[],"notes":"","desc":"SAC^k is the class of decision problems solvable by a family of depth-O(logkn) circuits with unbounded-fanin OR & bounded-fanin AND gates. Negations are only allowed at the input level. A uniformity condition may also be imposed. SAC^k sits naturally 'halfway' between NC^k and AC^k.","related":["SAC^1","AC^0"],"children":["AC^0"]},{"name":"SAC^1","equals":["LOGCFL"],"properties":[],"notes":"","desc":"Semi-Unbounded-Fanin AC^1. See {ref:SAC^0} for definition. SAC^1 (with a uniformity condition) = LOGCFL, and without a uniformity condition = LOGCFL/poly, see {ref:Joh90}{ref:Ven91}.","related":["LOGCFL","AC^1","SAC^0"],"children":["AC^1"]},{"name":"SBP","equals":[],"properties":[],"notes":"TODO closed under union, ref BGM02.","desc":"Small Bounded-Error Probability. The class of decision problems for which the following holds. There exists a #P function f and an FP function g such that, for all inputs x,\n If the answer is \"yes\" then f(x) > g(x).\n If the answer is \"no\" then f(x) < g(x)/2.\n Defined in {ref:BGM02}.","related":["MA","AM","A_0PP","AWPP"],"children":["A_0PP","AM"]},{"name":"SF","equals":[],"properties":[],"notes":"","desc":"Star-free languages, see https://en.wikipedia.org/wiki/Star-free_language. A subset of regular languages, where constant terms are allowed, and then we take the closure under complementation, union, and concatenation. Intersection comes for free. For example, the regex (ab)* is in this class, but (aa)* is not.","related":["REG"],"children":["AC^0","REG"]},{"name":"SZK","equals":[],"properties":[],"notes":"todo def","desc":"Statistical Zero Knowledge.","related":[],"children":["DQP","AM","coAM"]},{"name":"TC","equals":false,"properties":[],"notes":"","desc":"Threshold Circuits","related":["AC","NC","TC^0"],"children":[]},{"name":"TC^0","equals":[],"properties":[],"notes":"","desc":"Constant-Depth Threshold Circuits","related":["ACC^0","NC^0","AC^0","TC"],"children":["NC^1"]},{"name":"TC^1","equals":[],"properties":[],"notes":"","desc":"Log-Depth Threshold Circuits","related":["NC^0","AC^1","TC","TC^0"],"children":["NC^2"]},{"name":"TOWER","equals":[],"properties":[],"notes":"","desc":"Power-tower time. Solvable in time f(x), where f can be expressed using tetration (and +, *, ^, 0, 1).","related":["ELEMENTARY","PR"],"children":["PR"]},{"name":"ZPP","equals":[],"properties":[],"notes":"todo the polytime yes/no/unknown definition. todo the two-machine definition","desc":"Zero error Probabilistic Polynomial time. Problems with a probabilistic Turing machine with zero error and polynomial expected running time","related":["RP","BPP"],"children":["RP","coRP"]},{"name":"Δ2","equals":[],"properties":[],"notes":"","desc":"P^NP. The weakest class at the second level in the polynomial hierarchy.","related":["Π2","Σ2","PH"],"children":["Σ2","Π2"]},{"name":"Π2","equals":[],"properties":[],"notes":"","desc":"Universal polynomial time, 2 alternations. coNP^NP, at the second level in the polynomial hierarchy.","related":["Δ2","Σ2","PH"],"children":["PH"]},{"name":"Σ2","equals":[],"properties":[],"notes":"","desc":"Existential polynomial time, 2 alternations. NP^coNP, at the second level in the polynomial hierarchy.","related":["Π2","Δ2","PH"],"children":["PH"]},{"name":"nuACC^0","equals":[],"properties":["nonuniform"],"notes":"","desc":"{lang:ACC^0} but with no uniformity condition.","related":["ACC^0"],"children":[]}]